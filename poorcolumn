#!/usr/bin/env sh
# poorcolumn â€” minimal column(1) clone with basic -s/-t support
# description: minimal column(1) clone with basic -s/-t support
# version: <GIT_COMMIT_SHA>
# icon: mdi:table

set -eu

resolve_script_dir() {
  script_path=$0

  case "$script_path" in
    */*)
      ;;
    *)
      command_path=$(command -v -- "$script_path" 2>/dev/null || true)
      if [ -n "$command_path" ]
      then
        script_path=$command_path
      fi
      ;;
  esac

  if command -v readlink >/dev/null 2>&1
  then
    while link_target=$(readlink "$script_path" 2>/dev/null)
    do
      case "$link_target" in
        /*)
          script_path=$link_target
          ;;
        *)
          dir_name=$(dirname -- "$script_path")
          script_path=$dir_name/$link_target
          ;;
      esac
    done
  fi

  dir_name=$(dirname -- "$script_path")
  if CDPATH='' cd -- "$dir_name" >/dev/null 2>&1
  then
    pwd -P
  else
    return 1
  fi
}

SCRIPT_DIR=$(resolve_script_dir)
if [ -z "${SCRIPT_DIR:-}" ]
then
  exit 9
fi

# Global variables
SCRIPT_NAME="poorcolumn"
SEP=""  # custom separator (literal string)
SEP_SET=""

# Source echo utilities - this line gets replaced during templating
# shellcheck disable=SC1091  # File is included via templating
. "${SCRIPT_DIR}/lib/echo.sh" # <TEMPLATE>

usage() {
  cat <<USAGE >&2
Usage: ${SCRIPT_NAME} [--debug] [--trace] [-t] [-s SEPARATOR] [FILE...]
Align input into columns (table layout only).
  --debug            Enable debug output
  --trace            Enable shell tracing (set -x)
  -t                 align fields as a table (accepted for compatibility)
  -s SEPARATOR       split input using SEPARATOR instead of whitespace
  -h, --help         show this help
USAGE
}

main() {
  # Early return for sourcing support
  if [ -n "${SOURCED:-}" ]
  then
    return 0
  fi

  while [ $# -gt 0 ]
  do
    case "$1" in
      --debug)
        DEBUG=1
        export DEBUG  # Export for use by echo.sh functions
        shift
        ;;
      --trace)
        set -x
        shift
        ;;
      -h|--help)
        usage
        return 0
        ;;
      -t)
        # table layout is currently the only mode implemented
        shift
        ;;
      -s)
        if [ $# -lt 2 ]
        then
          echo_error "poorcolumn: -s requires an argument"
          usage
          return 2
        fi
        SEP="$2"
        SEP_SET=1
        shift 2
        ;;
      -s*)
        SEP="${1#-s}"
        if [ -z "$SEP" ]
        then
          echo_error "poorcolumn: -s requires an argument"
          usage
          return 2
        fi
        SEP_SET=1
        shift
        ;;
      --)
        shift
        break
        ;;
      -*)
        echo_error "poorcolumn: unsupported flag: $1"
        usage
        return 2
        ;;
      *)
        break
        ;;
    esac
  done

  if [ -n "${SEP_SET:-}" ] && [ -z "$SEP" ]
  then
    echo_error "poorcolumn: separator cannot be empty"
    return 2
  fi

  awk -v SEP="$SEP" -v SEP_SET="${SEP_SET:-}" '
  BEGIN {
    sep_set = (SEP_SET != "")
    colsep = "  "
    FS = "[[:space:]]+"
  }
  {
    line = $0
    row += 1

    if (line ~ /^[[:space:]]*$/) {
      blank[row] = 1
      next
    }

    delete fields
    if (sep_set) {
      n = split_literal(line, fields, SEP)
    } else {
      gsub(/^[[:space:]]+/, "", line)
      gsub(/[[:space:]]+$/, "", line)
      if (line == "") {
        blank[row] = 1
        next
      }
      n = split(line, fields)
    }

    cols_for_row[row] = n
    if (n > cols) {
      cols = n
    }

    for (i = 1; i <= n; i++) {
      cell = fields[i]
      data[row, i] = cell
      len = display_width(cell)
      if (len > width[i]) {
        width[i] = len
      }
    }
  }
  END {
    for (r = 1; r <= row; r++) {
      if (blank[r]) {
        print ""
        continue
      }

      n = cols_for_row[r]
      if (n == 0) {
        print ""
        continue
      }

      for (i = 1; i <= cols; i++) {
        cell = data[r, i]
        w = width[i]
        if (i < cols) {
          print_cell(cell, w, colsep)
        } else {
          print_cell(cell, w, "")
        }
      }

      printf "\n"
    }
  }

  function split_literal(str, arr, sep,    n, pos, slen) {
    n = 0
    slen = length(sep)
    if (slen == 0) {
      arr[++n] = str
      return n
    }
    while ((pos = index(str, sep)) > 0) {
      arr[++n] = substr(str, 1, pos - 1)
      str = substr(str, pos + slen)
    }
    arr[++n] = str
    return n
  }

  function print_cell(cell, width, sep,    pad) {
    printf "%s", cell
    pad = width - display_width(cell)
    if (pad < 0) {
      pad = 0
    }
    if (sep != "") {
      while (pad-- > 0) {
        printf " "
      }
      printf "%s", sep
    }
  }

  function display_width(str, copy) {
    copy = str
    gsub(/\033\[[0-9;]*m/, "", copy)
    gsub("\357\270\217", "", copy)  # strip variation selector-16
    gsub("\342\200\215", "", copy)  # zero-width joiner
    gsub("\342\200\214", "", copy)  # zero-width non-joiner
    return length(copy)
  }
  ' "$@"
}

main "$@"
