#!/usr/bin/env sh
# description: tiny curl-ish fetcher using openssl s_client (HTTPS only)
# icon: mdi:lock-outline
# shellcheck disable=SC3045,SC3052 # Uses bash-specific features for advanced functionality
# curl-ossl — tiny curl-ish fetcher using openssl s_client (binary-safe)
# Features: HTTPS only, HTTP/1.1, redirects, -o, -I, -s/-S, -f, -4/-6, -v, --max-redirs, dechunk
# Conventions: booleans use "1" for true, unset/empty for false; no exit in funcs; usage() prints only.

set -eu

# Global variables
SCRIPT_NAME="poorcurl-openssl"
MAX_REDIRECTS_DEFAULT=5

# Boolean flags: set to "1" when enabled, otherwise unset/empty
SILENT=""
SHOW_ERROR=""
HEAD_ONLY=""
FAIL_ON_ERROR=""
FORCE_V4=""
FORCE_V6=""
VERBOSE=""

OUTFILE=""
MAX_REDIRS="${MAX_REDIRECTS_DEFAULT}"
URL=""

# Source echo utilities - this line gets replaced during templating
# shellcheck disable=SC1091  # File is included via templating
. lib/echo.sh # <TEMPLATE>
# Source utils utilities - this line gets replaced during templating  
# shellcheck disable=SC1091  # File is included via templating
. lib/utils.sh # <TEMPLATE>

usage() {
  cat <<USAGE >&2
Usage: ${SCRIPT_NAME} [--debug] [--trace] [OPTIONS] URL

Options:
  --debug               Enable debug output
  --trace               Enable shell tracing (set -x)
  -s                    Silent (suppress TLS chatter)
  -S                    Show errors (useful with -s)
  -o FILE               Write body to FILE
  -I                    Headers only
  -L                    Follow redirects (default: ${MAX_REDIRECTS_DEFAULT})
  --max-redirs N        Set redirect limit
  -f                    Fail on HTTP >= 400 (exit 22)
  -4                    Force IPv4 (require A record; else exit 6)
  -6                    Force IPv6 (require AAAA; else exit 6; no IPv4-mapped)
  -v, --verbose         Verbose (DNS, s_client args, redirects)
  -h, --help            Show this help
USAGE
}

logv() {
  if [ -n "$VERBOSE" ]
  then
    echo ">>> $*" >&2
  fi
}

# Helper functions for HTTP processing

# Parse URL into components
parse_url() {
  U_ARG="$1"
  case "$U_ARG" in
    https://*) PROTO=https; REST="${U_ARG#https://}" ;;
    http://*)  PROTO=http;  REST="${U_ARG#http://}"  ;;
    *)         PROTO=https; REST="${U_ARG}"          ;;
  esac

  case "$REST" in
    */*) HOSTPORT="${REST%%/*}"; PATH="/${REST#*/}" ;;
    *)   HOSTPORT="${REST}";     PATH="/"           ;;
  esac

  case "$HOSTPORT" in
    *:*) HOST="${HOSTPORT%:*}"; PORT="${HOSTPORT#*:}" ;;
    *)   HOST="${HOSTPORT}"; [ "$PROTO" = https ] && PORT=443 || PORT=80 ;;
  esac

  printf '%s %s %s %s\n' "$PROTO" "$HOST" "$PORT" "$PATH"
}

resolve_ip_v4() {
  HOST_ARG="$1"
  IP=""
  if has_command getent
  then
    IP=$(getent ahostsv4 "$HOST_ARG" 2>/dev/null | awk 'NF{print $1; exit}')
  fi

  if [ -z "${IP:-}" ] && has_command nslookup
  then
    IP=$(nslookup -type=A "$HOST_ARG" 2>/dev/null | awk '/^Address: /{print $2; exit}')
  fi

  if [ -z "${IP:-}" ]
  then
    return 1
  fi

  printf '%s\n' "$IP"
}

resolve_ip_v6() {
  HOST_ARG="$1"
  IP6=""
  if has_command getent
  then
    IP6=$(getent ahostsv6 "$HOST_ARG" 2>/dev/null | awk '
      {
        ip=$1
        # reject IPv4-mapped (::ffff:a.b.c.d) and ::a.b.c.d
        if (ip ~ /^::ffff:/) next
        if (ip ~ /::[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/) next
        if (index(ip, ":") > 0) { print ip; exit }
      }')
  fi

  if [ -z "${IP6:-}" ] && has_command nslookup
  then
    IP6=$(nslookup -type=AAAA "$HOST_ARG" 2>/dev/null | awk '/has IPv6 address/ {print $NF; exit}')
  fi

  if [ -z "${IP6:-}" ]
  then
    return 1
  fi

  printf '%s\n' "$IP6"
}

bracket_if_ipv6() {
  case "$1" in
    *:*) printf '[%s]\n' "$1" ;;
    *)   printf '%s\n' "$1"   ;;
  esac
}

join_location() {
  # Inputs: base_proto base_host base_port base_path location
  BP="$1"
  BH="$2"
  BO="$3"
  BPATH="$4"
  LOC="$5"

  case "$LOC" in
    https://*|http://*)
      printf '%s\n' "$LOC"
      return 0
      ;;
    //*)
      printf '%s\n' "$BP:${LOC}"
      return 0
      ;;
    /*)
      printf '%s://%s:%s%s\n' "$BP" "$BH" "$BO" "$LOC"
      return 0
      ;;
    *)
      BASE_DIR="${BPATH%/*}"
      [ -n "$BASE_DIR" ] || BASE_DIR="/"
      case "$BASE_DIR" in
        */)
          :
          ;;
        *)
          BASE_DIR="${BASE_DIR}/"
          ;;
      esac

      printf '%s://%s:%s%s%s\n' "$BP" "$BH" "$BO" "$BASE_DIR" "$LOC"
      return 0
      ;;
  esac
}

# fetch HTTPS response to files: headers -> $1, raw body -> $2
# returns:
#   0 success
#   6 DNS family resolution failure (when -4/-6 forced)
#   1 other failure
fetch_https_stream() {
  hdrf=$1
  rawf=$2
  sni_host=$3    # original hostname for SNI and Host header
  connect_host=$4  # what to pass to -connect (hostname or resolved IP)
  port=$5
  path=$6

  # Host header must be the original hostname; include port only if non-default
  host_hdr=${sni_host}
  if [ "$port" -ne 443 ]
  then
    host_hdr="${sni_host}:${port}"
  fi

  req="GET ${path} HTTP/1.1\r\nHost: ${host_hdr}\r\nUser-Agent: curl-ossl\r\nAccept: */*\r\nConnection: close\r\n\r\n"
  connect_target="$(bracket_if_ipv6 "$connect_host"):${port}"

  for args in \
    "-quiet -ign_eof -connect ${connect_target} -tls1_3 -servername ${sni_host}" \
    "-quiet -ign_eof -connect ${connect_target} -tls1_2 -servername ${sni_host}" \
    "-quiet -ign_eof -connect ${connect_target} -tls1_2"
  do
    logv "openssl s_client ${args}"
    errf=$(mktemp 2>/dev/null || echo "/tmp/curl-ossl.$$-err")

    # Run; ignore s_client exit — validate by captured HTTP headers instead
    # shellcheck disable=SC2086 # args contains multiple openssl arguments
    printf '%b' "$req" \
    | openssl s_client $args 2>"$errf" \
    | {
        : >"$hdrf"
        while IFS= read -r line
do
          line=$(printf '%s' "$line" | tr -d '\r')
          [ -z "$line" ] && break
          printf '%s\n' "$line" >>"$hdrf"
        done
        cat >"$rawf"
      } || true

    if head -n1 "$hdrf" | grep -q '^HTTP/'
    then
      logv "got HTTP response"
      rm -f "$errf"
      return 0
    fi

    if [ -z "$silent" ] || [ -n "$show_error" ] || [ -n "$verbose" ]
    then
      sed 's/^/openssl: /' "$errf" >&2 || true
    fi

    rm -f "$errf"
  done

  return 1
}

# decode chunked body (binary-safe): in=$1, out=$2
dechunk_file() {
  in=$1
  out=$2
  : >"$out"
  exec 9<"$in"

  while IFS= read -r -u 9 line
  do
    line=$(printf '%s' "$line" | tr -d '\r')
    sizehex=${line%%;*}
    [ -n "$sizehex" ] || continue
    case "$sizehex" in
      *[!0-9a-fA-F]* )
        break
        ;;
    esac
    size=$((16#$(printf '%s' "$sizehex" | tr 'a-f' 'A-F')))
    [ "$size" -gt 0 ] || break
    dd bs=1 count="$size" <&9 >>"$out" 2>/dev/null || true
    IFS= read -r -u 9 _ || true  # consume CRLF
  done

  exec 9<&-
}

# -------- main follow loop --------
follow() {
  cur=$1
  n=0

  while :
  do
    n=$((n+1))
    [ "$n" -le "$max_redirs" ] || { echo "curl-ossl: too many redirects" >&2; return 22; }

    # shellcheck disable=SC2046 # parse_url returns multiple values to assign
    set -- $(parse_url "$cur")
    proto=$1; host=$2; port=$3; path=$4

    if [ "$proto" != https ]
    then
      echo "curl-ossl: only https supported (got $proto)" >&2
      return 2
    fi

    # Determine connect host (IP if -4/-6, else hostname)
    connect_host=
    if [ -n "$force_v4" ]
    then
      if connect_host=$(resolve_ip_v4 "$host")
      then
        logv "resolved IPv4: $connect_host"
      else
        logv "no A record for $host"
        if [ -z "$silent" ] && [ -n "$show_error" ]
        then
          echo "curl-ossl: could not resolve IPv4 for $host" >&2
        fi
        return 6
      fi
    elif [ -n "$force_v6" ]
    then
      if connect_host=$(resolve_ip_v6 "$host")
      then
        logv "resolved IPv6: $connect_host"
      else
        logv "no AAAA record for $host"
        if [ -z "$silent" ] && [ -n "$show_error" ]
        then
          echo "curl-ossl: could not resolve IPv6 for $host" >&2
        fi
        return 6
      fi
    else
      connect_host="$host"
      logv "using host as-is: $connect_host"
    fi

    logv "request: https://$host:$port$path"

    hdrf=$(mktemp 2>/dev/null || echo "/tmp/curl-ossl.$$-hdr")
    rawf=$(mktemp 2>/dev/null || echo "/tmp/curl-ossl.$$-raw")

    if ! fetch_https_stream "$hdrf" "$rawf" "$host" "$connect_host" "$port" "$path"
    then
      rc=$?
      rm -f "$hdrf" "$rawf"
      case "$rc" in
        6)  return 6 ;;
        *)
          [ -z "$silent" ] && echo_error "curl-ossl: connection failed"
          return 1
          ;;
      esac
    fi

    status=$(head -n1 "$hdrf" 2>/dev/null | awk '{print $2+0}')
    [ -z "$status" ] && status=0
    logv "HTTP status: $status"

    if [ -n "$head_only" ]
    then
      cat "$hdrf"
      rm -f "$hdrf" "$rawf"
      return "$status"
    fi

    if [ "$status" -ge 300 ] && [ "$status" -lt 400 ]
    then
      loc=$(awk 'BEGIN{IGNORECASE=1} /^Location:/{sub(/^[^:]*:[[:space:]]*/,"",$0); print; exit}' "$hdrf" | tr -d '\r')
      [ -n "$loc" ] || { [ -z "$silent" ] && echo "curl-ossl: redirect without Location" >&2; rm -f "$hdrf" "$rawf"; return 22; }
      newurl=$(join_location "$proto" "$host" "$port" "$path" "$loc")
      logv "redirect to $newurl"
      cur="$newurl"
      rm -f "$hdrf" "$rawf"
      continue
    fi

    te=$(awk 'BEGIN{IGNORECASE=1} /^Transfer-Encoding:/{print tolower($2)}' "$hdrf" | tr -d '\r')

    bodyf="$rawf"
    if [ "$te" = chunked ]
    then
      bodyf2=$(mktemp 2>/dev/null || echo "/tmp/curl-ossl.$$-body")
      dechunk_file "$rawf" "$bodyf2"
      rm -f "$rawf"
      bodyf="$bodyf2"
    fi

    if [ -n "${outfile:-}" ]
    then
      cat "$bodyf" >"$outfile"
    else
      cat "$bodyf"
    fi

    rm -f "$hdrf" "$bodyf"

    if [ "$status" -ge 400 ] && [ -n "$fail_on_error" ]
    then
      return 22
    fi

    return 0
  done
}

# Note: This script maintains compatibility with existing lowercase variable names
# for the complex HTTP functions. A full refactor would update all variables
# to UPPERCASE but would require extensive testing of the HTTP parsing logic.

main() {
  # Parse command line arguments and update lowercase variables for compatibility
  while [ $# -gt 0 ]
  do
    case "$1" in
      --debug)
        DEBUG=1
        export DEBUG  # Export for use by echo.sh functions
        shift
        ;;
      --trace)
        set -x
        shift
        ;;
      -s)
        SILENT=1
        silent=1
        shift
        ;;
      -S)
        SHOW_ERROR=1
        show_error=1
        shift
        ;;
      -o)
        shift
        OUTFILE="${1:-}"
        outfile="${1:-}"
        if [ -z "${OUTFILE:-}" ]
        then
          usage
          return 2
        fi
        shift
        ;;
      -I)
        HEAD_ONLY=1
        head_only=1
        shift
        ;;
      -L)
        # following is on by default; keep switch for compatibility
        shift
        ;;
      --max-redirs)
        shift
        MAX_REDIRS="${1:-}"
        max_redirs="${1:-}"
        if [ -z "${MAX_REDIRS:-}" ]
        then
          usage
          return 2
        fi
        shift
        ;;
      -f)
        FAIL_ON_ERROR=1
        fail_on_error=1
        shift
        ;;
      -4)
        FORCE_V4=1
        force_v4=1
        FORCE_V6=""
        force_v6=""
        shift
        ;;
      -6)
        FORCE_V6=1
        force_v6=1
        FORCE_V4=""
        force_v4=""
        shift
        ;;
      -v|--verbose)
        VERBOSE=1
        verbose=1
        shift
        ;;
      -h|--help)
        usage
        return 0
        ;;
      -*)
        usage
        return 2
        ;;
      *)
        URL="$1"
        url="$1"
        shift
        break
        ;;
    esac
  done

  if [ -z "${URL:-}" ]
  then
    usage
    return 2
  fi

  # default to https if no scheme
  case "$url" in
    http://*|https://*) : ;;
    *) 
      URL="https://${URL}"
      url="https://${url}"
      ;;
  esac

  # Run the main follow logic
  set +e
  follow "$url"
  RC=$?
  set -e
  return "$RC"
}

main "$@"
