#!/usr/bin/env sh
# poornmap â€” nmap-like port scanner using nc
# description: nmap-like port scanner using nc
# version: <GIT_COMMIT_SHA>
# icon: mdi:network-outline

set -eu

# Global variables
SCRIPT_NAME="poornmap"
TIMEOUT=3
PING_SCAN=1
JSON_OUTPUT=""
PORTS=""
HOST=""
PROG="${PROG:-}"  # Environment variable for tool override

# Tool detection results
NETCAT_TOOL=""
NETCAT_ARGS=""

# JSON output variables
JSON_RESULTS=""
JSON_HOST=""
JSON_SCAN_TIME=""

# Source echo utilities - this line gets replaced during templating
# shellcheck disable=SC1091  # File is included via templating
. lib/echo.sh # <TEMPLATE>
# Source utils utilities - this line gets replaced during templating
# shellcheck disable=SC1091  # File is included via templating
. lib/utils.sh # <TEMPLATE>

usage() {
  cat <<USAGE >&2
Usage: ${SCRIPT_NAME} [--debug] [--trace] [OPTIONS] HOST
Options:
  --debug          Enable debug output
  --trace          Enable shell tracing (set -x)
  -p PORTS         Port specification (e.g., 22,80,443 or 1-1000)
  -Pn              Skip ping scan (disable host discovery)
  --timeout SECS   Timeout in seconds (default: ${TIMEOUT})
  --json           Output results in JSON format
  --prog TOOL      Force specific tool (ncat, nc, netcat, busybox, bash)
  -h, --help       Show this help message

Environment Variables:
  PROG             Same as --prog, override tool detection
  NO_COLOR         Disable colored output
  QUIET            Suppress info messages

Examples:
  ${SCRIPT_NAME} -p 22,80,443 example.com
  ${SCRIPT_NAME} -p 1-1000 -Pn 192.168.1.1
  ${SCRIPT_NAME} --json -p 80,443 google.com
  ${SCRIPT_NAME} --prog nc -p 22 github.com
  PROG=bash ${SCRIPT_NAME} -p 443 example.com
USAGE
}

# Detect the best available netcat tool
detect_netcat_tool() {
  # If PROG is set, try to use that tool specifically
  if [ -n "$PROG" ]
  then
    case "$PROG" in
      "ncat")
        if has_command ncat
        then
          NETCAT_TOOL="ncat"
          NETCAT_ARGS="-z -v"
          return 0
        fi
        ;;
      "nc")
        if has_command nc
        then
          # Test if it supports -z flag
          if nc -z 2>&1 | grep -q "usage:"
          then
            NETCAT_TOOL="nc"
            NETCAT_ARGS="-z -v"
          else
            NETCAT_TOOL="nc"
            NETCAT_ARGS="-v"
          fi
          return 0
        fi
        ;;
      "netcat")
        if has_command netcat
        then
          NETCAT_TOOL="netcat"
          NETCAT_ARGS="-z -v"
          return 0
        fi
        ;;
      "busybox")
        if has_command busybox && busybox nc 2>&1 | grep -q "Usage:"
        then
          NETCAT_TOOL="busybox nc"
          NETCAT_ARGS="-v"
          return 0
        fi
        ;;
      "bash")
        if has_command bash
        then
          NETCAT_TOOL="bash"
          NETCAT_ARGS=""
          return 0
        fi
        ;;
      *)
        echo_error "Unknown tool specified: ${PROG}"
        return 1
        ;;
    esac
    echo_error "Specified tool '${PROG}' not available"
    return 1
  fi

  # Auto-detection: Try tools from most powerful to least convenient for us
  # ncat (from nmap) - most powerful
  if has_command ncat
  then
    NETCAT_TOOL="ncat"
    NETCAT_ARGS="-z -v"
    return 0
  fi

  # OpenBSD netcat - good feature set
  if has_command nc
  then
    # Test if it supports -z flag (OpenBSD/traditional nc)
    if nc -z 2>&1 | grep -q "usage:"
    then
      NETCAT_TOOL="nc"
      NETCAT_ARGS="-z -v"
      return 0
    fi
  fi

  # GNU netcat - different syntax
  if has_command netcat
  then
    NETCAT_TOOL="netcat"
    NETCAT_ARGS="-z -v"
    return 0
  fi

  # Busybox netcat - minimal but widely available
  if has_command busybox && busybox nc 2>&1 | grep -q "Usage:"
  then
    NETCAT_TOOL="busybox nc"
    NETCAT_ARGS="-v"
    return 0
  fi

  # Regular nc without -z support (fallback)
  if has_command nc
  then
    NETCAT_TOOL="nc"
    NETCAT_ARGS="-v"
    return 0
  fi

  # bash /dev/tcp fallback
  if has_command bash
  then
    NETCAT_TOOL="bash"
    NETCAT_ARGS=""
    return 0
  fi

  return 1
}

# Test a single port using the detected tool
test_port() {
  HOST_ARG="$1"
  PORT_ARG="$2"
  TIMEOUT_VAL="$3"

  case "$NETCAT_TOOL" in
    "ncat"|"nc"|"netcat")
      if echo "$NETCAT_ARGS" | grep -q -- "-z"
      then
        # Tool supports -z flag for port scanning
        # shellcheck disable=SC2086  # NETCAT_ARGS contains multiple arguments
        timeout "$TIMEOUT_VAL" ${NETCAT_TOOL} ${NETCAT_ARGS} -w1 "$HOST_ARG" "$PORT_ARG" >/dev/null 2>&1
      else
        # Tool doesn't support -z, use connection attempt
        # shellcheck disable=SC2086  # NETCAT_ARGS contains multiple arguments
        timeout "$TIMEOUT_VAL" ${NETCAT_TOOL} ${NETCAT_ARGS} -w1 "$HOST_ARG" "$PORT_ARG" </dev/null >/dev/null 2>&1
      fi
      ;;
    "busybox nc")
      # Busybox nc doesn't support -z, use connection attempt
      timeout "$TIMEOUT_VAL" busybox nc -w1 "$HOST_ARG" "$PORT_ARG" </dev/null >/dev/null 2>&1
      ;;
    "bash")
      # Use bash's /dev/tcp
      timeout "$TIMEOUT_VAL" bash -c "exec 3<>/dev/tcp/${HOST_ARG}/${PORT_ARG} && exec 3<&- && exec 3>&-" >/dev/null 2>&1
      ;;
    *)
      return 1
      ;;
  esac
}

# Check if a string is a valid integer
is_integer() {
  case "$1" in
    ''|*[!0-9]*) return 1 ;;
    *) return 0 ;;
  esac
}

# Parse port specification (e.g., "22,80,443" or "1-1000")
parse_ports() {
  PORT_SPEC="$1"
  PORTS_LIST=""

  # Handle comma-separated ports
  for PORT_RANGE in $(echo "$PORT_SPEC" | tr ',' ' ')
  do
    case "$PORT_RANGE" in
      *-*)
        # Handle port ranges like 1-1000
        START_PORT=$(echo "$PORT_RANGE" | cut -d'-' -f1)
        END_PORT=$(echo "$PORT_RANGE" | cut -d'-' -f2)

        # Validate that both are integers
        if ! is_integer "$START_PORT" || ! is_integer "$END_PORT"
        then
          echo_error "Invalid port range: ${PORT_RANGE} (ports must be integers)"
          return 1
        fi

        # Validate range
        if [ "$START_PORT" -gt "$END_PORT" ] || [ "$START_PORT" -lt 1 ] || [ "$END_PORT" -gt 65535 ]
        then
          echo_error "Invalid port range: ${PORT_RANGE} (must be 1-65535)"
          return 1
        fi

        # Generate port list
        I="$START_PORT"
        while [ "$I" -le "$END_PORT" ]
        do
          PORTS_LIST="${PORTS_LIST} ${I}"
          I=$((I + 1))
        done
        ;;
      *)
        # Single port
        if ! is_integer "$PORT_RANGE"
        then
          echo_error "Invalid port: ${PORT_RANGE} (must be an integer)"
          return 1
        fi

        if [ "$PORT_RANGE" -lt 1 ] || [ "$PORT_RANGE" -gt 65535 ]
        then
          echo_error "Invalid port: ${PORT_RANGE} (must be 1-65535)"
          return 1
        fi
        PORTS_LIST="${PORTS_LIST} ${PORT_RANGE}"
        ;;
    esac
  done

  echo "$PORTS_LIST"
}

# Initialize JSON output
json_init() {
  JSON_HOST="$1"
  JSON_SCAN_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  JSON_RESULTS=""
}

# Add port result to JSON
json_add_port() {
  PORT_ARG="$1"
  STATE_ARG="$2"

  if [ -n "$JSON_RESULTS" ]
  then
    JSON_RESULTS="${JSON_RESULTS},"
  fi

  JSON_RESULTS="${JSON_RESULTS}{\"port\":${PORT_ARG},\"state\":\"${STATE_ARG}\"}"
}

# Output final JSON
json_output() {
  cat <<JSON_EOF
{
  "host": "${JSON_HOST}",
  "scan_time": "${JSON_SCAN_TIME}",
  "scanner": "poornmap",
  "tool_used": "${NETCAT_TOOL}",
  "ping_scan_disabled": $([ -z "${PING_SCAN:-}" ] && echo "true" || echo "false"),
  "ports": [${JSON_RESULTS}]
}
JSON_EOF
}

# Main scanning function
scan_ports() {
  SCAN_HOST="$1"
  SCAN_PORTS="$2"

  if [ -n "${JSON_OUTPUT:-}" ]
  then
    json_init "$SCAN_HOST"
  else
    echo_info "Starting port scan on ${SCAN_HOST}"
    echo_info "Using tool: ${NETCAT_TOOL}"
  fi

  OPEN_PORTS=0
  TOTAL_PORTS=0

  for PORT in ${SCAN_PORTS}
  do
    TOTAL_PORTS=$((TOTAL_PORTS + 1))

    if test_port "$SCAN_HOST" "$PORT" "$TIMEOUT"
    then
      # Port is open
      OPEN_PORTS=$((OPEN_PORTS + 1))
      if [ -n "${JSON_OUTPUT:-}" ]
      then
        json_add_port "$PORT" "open"
      else
        echo_success "${SCAN_HOST}:${PORT} OPEN"
      fi
    else
      # Port is closed/filtered
      if [ -n "${JSON_OUTPUT:-}" ]
      then
        json_add_port "$PORT" "closed"
      else
        echo_error "${SCAN_HOST}:${PORT} CLOSED"
      fi
    fi
  done

  if [ -n "${JSON_OUTPUT:-}" ]
  then
    json_output
  else
    echo_info "Scan complete: ${OPEN_PORTS}/${TOTAL_PORTS} ports open"
  fi

  # Return non-zero if no ports are open
  [ "$OPEN_PORTS" -gt 0 ]
}

main() {
  # Early return for sourcing support
  if [ -n "${SOURCED:-}" ]
  then
    return 0
  fi

  # Parse command line arguments
  while [ $# -gt 0 ]
  do
    case "$1" in
      --debug)
        DEBUG=1
        export DEBUG  # Export for use by echo.sh functions
        shift
        ;;
      --trace)
        set -x
        shift
        ;;
      -h|--help)
        usage
        return 0
        ;;
      -p)
        if [ -z "$2" ]
        then
          echo_error "Option -p requires an argument"
          return 1
        fi
        PORTS="$2"
        shift 2
        ;;
      -Pn)
        PING_SCAN=""
        shift
        ;;
      --timeout)
        if [ -z "$2" ]
        then
          echo_error "Option --timeout requires an argument"
          return 1
        fi
        TIMEOUT="$2"
        shift 2
        ;;
      --json)
        JSON_OUTPUT=1
        shift
        ;;
      --prog)
        if [ -z "$2" ]
        then
          echo_error "Option --prog requires an argument"
          return 1
        fi
        PROG="$2"
        shift 2
        ;;
      -*)
        echo_error "Unknown option: $1"
        usage >&2
        return 1
        ;;
      *)
        if [ -z "$HOST" ]
        then
          HOST="$1"
        else
          echo_error "Multiple hosts not supported"
          return 1
        fi
        shift
        ;;
    esac
  done

  # Validate arguments
  if [ -z "$HOST" ]
  then
    echo_error "No host specified"
    usage >&2
    return 1
  fi

  if [ -z "$PORTS" ]
  then
    echo_error "No ports specified (use -p option)"
    usage >&2
    return 1
  fi

  # Detect netcat tool
  if ! detect_netcat_tool
  then
    echo_error "No suitable network tool found (tried: ncat, nc, netcat, busybox nc, bash)"
    return 1
  fi

  # Parse ports
  if ! PARSED_PORTS=$(parse_ports "$PORTS")
  then
    return 1
  fi

  # Optional ping check (if not disabled with -Pn)
  if [ -n "${PING_SCAN:-}" ]
  then
    if has_command ping
    then
      if ! ping -c 1 -W 3 "$HOST" >/dev/null 2>&1
      then
        if [ -n "${JSON_OUTPUT:-}" ]
        then
          json_init "$HOST"
          json_output
        else
          echo_warning "Host ${HOST} appears to be down (ping failed)"
          echo_info "Use -Pn to skip ping scan"
        fi
        return 1
      fi
    else
      if [ -z "${JSON_OUTPUT:-}" ]
      then
        echo_warning "ping command not available, skipping host discovery"
      fi
    fi
  fi

  # Perform the scan
  scan_ports "$HOST" "$PARSED_PORTS"
}

main "$@"
