#!/usr/bin/env sh
# poor-install â€” copy poor* tools into a destination directory

set -eu

# Source echo utilities - this line gets replaced during templating
# shellcheck disable=SC1091  # File is included via templating
. lib/echo.sh # <TEMPLATE>

# Ensure we run from the directory containing the script so we can find the tools
SCRIPT_PATH=$0
if [ "${SCRIPT_PATH%/*}" = "$SCRIPT_PATH" ]
then
  SCRIPT_PATH=$(command -v -- "$SCRIPT_PATH" 2>/dev/null || echo "$SCRIPT_PATH")
fi
while LINK_TARGET=$(readlink "$SCRIPT_PATH" 2>/dev/null)
do
  case "$LINK_TARGET" in
    /*)
      SCRIPT_PATH=${LINK_TARGET}
      ;;
    *)
      SCRIPT_DIRNAME=$(dirname -- "$SCRIPT_PATH")
      SCRIPT_PATH=${SCRIPT_DIRNAME}/${LINK_TARGET}
      ;;
  esac
done
SCRIPT_DIR=$(CDPATH='' cd -- "$(dirname -- "$SCRIPT_PATH")" && pwd -P)
SOURCE_DIR=${SCRIPT_DIR}
cd "$SOURCE_DIR"

usage() {
  cat <<'USAGE' >&2
Usage: poor-install [OPTIONS] [TOOL...]

Options:
  --dest DIR       Install into DIR (or set DEST environment variable)
  --emulate        Strip leading "poor" when naming installed binaries
  --clear          Remove DEST before install. With --uninstall try removing DEST after
  --uninstall      Remove matching files instead of installing
  --ignore NAME    Skip a tool (repeatable, accepts NAME or poorNAME)
  --skip NAME      Alias for --ignore
  -h, --help       Show this help

If TOOL arguments are provided, only those tools are installed. Otherwise all
available poor* scripts are copied.
USAGE
}

error_missing_arg() {
  echo_error "option '$1' requires an argument"
  usage
  exit 2
}

list_contains() {
  LIST=$1
  NEEDLE=$2
  for ENTRY in $LIST
do
    if [ "$ENTRY" = "$NEEDLE" ]
    then
      return 0
    fi
  done
  return 1
}

is_pattern() {
  case "$1" in
    *\**|*\?*|*\[*|*\]*)
      return 0
      ;;
  esac
  return 1
}

matches_pattern() {
  VALUE=$1
  PATTERN=$2
  # shellcheck disable=SC2254 # PATTERN is intended to be a glob pattern
  case "$VALUE" in
    $PATTERN)
      return 0
      ;;
  esac
  return 1
}

resolve_name() {
  TARGET=$1
  for SCRIPT_CANDIDATE in $AVAILABLE_SCRIPTS
do
    BASE_NAME=${SCRIPT_CANDIDATE##*/}
    ALT_NAME=${BASE_NAME#poor}
    ALT_NAME=${ALT_NAME#-}
    if [ "$TARGET" = "$BASE_NAME" ] || [ "$TARGET" = "$ALT_NAME" ]
    then
      echo "$SCRIPT_CANDIDATE"
      return 0
    fi
  done
  return 1
}

expand_pattern_matches() {
  PATTERN=$1
  RESULTS=""
  for SCRIPT_CANDIDATE in $AVAILABLE_SCRIPTS
do
    BASE_NAME=${SCRIPT_CANDIDATE##*/}
    ALT_NAME=${BASE_NAME#poor}
    ALT_NAME=${ALT_NAME#-}
    if matches_pattern "$BASE_NAME" "$PATTERN" || matches_pattern "$ALT_NAME" "$PATTERN"
    then
      RESULTS="$RESULTS $SCRIPT_CANDIDATE"
    fi
  done
  if [ -n "$RESULTS" ]
then
    echo "$RESULTS"
    return 0
  fi
  return 1
}

DEST=${DEST:-}
EMULATE=false
IGNORE_ARGS=""
CLEAR_DEST=false
UNINSTALL=false

while [ $# -gt 0 ]
do
  case "$1" in
    --dest)
      shift
      if [ $# -eq 0 ]
      then
        error_missing_arg --dest
      fi
      DEST=$1
      shift
      ;;
    --dest=*)
      DEST=${1#--dest=}
      shift
      ;;
    --emulate)
      EMULATE=true
      shift
      ;;
    --clear)
      CLEAR_DEST=true
      shift
      ;;
    --uninstall)
      UNINSTALL=true
      shift
      ;;
    --ignore|--skip)
      OPTION_NAME=$1
      shift
      if [ $# -eq 0 ]
      then
        error_missing_arg "$OPTION_NAME"
      fi
      IGNORE_ARGS="$IGNORE_ARGS $1"
      shift
      ;;
    --ignore=*|--skip=*)
      OPTION_VALUE=${1#*=}
      IGNORE_ARGS="$IGNORE_ARGS $OPTION_VALUE"
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    -*)
      echo_error "unknown option '$1'"
      usage
      exit 2
      ;;
    *)
      break
      ;;
  esac
done

SELECT_ARGS=""
while [ $# -gt 0 ]
do
  SELECT_ARGS="$SELECT_ARGS $1"
  shift
done

if [ -z "$DEST" ]
then
  echo_error "destination required (--dest or DEST env var)"
  exit 2
fi

if [ "$UNINSTALL" = true ]
then
  if [ ! -d "$DEST" ]
then
    echo "destination '$DEST' does not exist, nothing to uninstall" >&2
    exit 0
  fi
else
  mkdir -p "$DEST"
  if [ "$CLEAR_DEST" = true ] && [ -d "$DEST" ]
then
    find "$DEST" -mindepth 1 -maxdepth 1 -exec rm -rf {} + 2>/dev/null || true
    echo "cleared $DEST"
  fi
fi

AVAILABLE_SCRIPTS=""
for SCRIPT_PATH_CANDIDATE in poor*
do
  if [ -f "$SCRIPT_PATH_CANDIDATE" ]
then
    AVAILABLE_SCRIPTS="$AVAILABLE_SCRIPTS $SCRIPT_PATH_CANDIDATE"
  fi
done

if [ -z "$AVAILABLE_SCRIPTS" ]
then
  echo "no tools found in current directory" >&2
  exit 1
fi

IGNORE_SCRIPTS=""
for NAME_ARG in $IGNORE_ARGS
do
  if [ -z "$NAME_ARG" ]
then
    continue
  fi
  if is_pattern "$NAME_ARG"
then
    if MATCHES=$(expand_pattern_matches "$NAME_ARG" 2>/dev/null)
    then
      for SCRIPT_CANDIDATE in $MATCHES
      do
        if ! list_contains "$IGNORE_SCRIPTS" "$SCRIPT_CANDIDATE"
        then
          IGNORE_SCRIPTS="$IGNORE_SCRIPTS $SCRIPT_CANDIDATE"
        fi
      done
      continue
    else
      echo_warning "no tool matches pattern '${NAME_ARG}'"
      continue
    fi
  fi
  if SCRIPT_MATCH=$(resolve_name "$NAME_ARG" 2>/dev/null)
then
    if ! list_contains "$IGNORE_SCRIPTS" "$SCRIPT_MATCH"
    then
      IGNORE_SCRIPTS="$IGNORE_SCRIPTS $SCRIPT_MATCH"
    fi
  else
    echo_warning "no tool matches '${NAME_ARG}'"
  fi
done

TO_INSTALL=""
if [ -n "$SELECT_ARGS" ]
then
  for NAME_ARG in $SELECT_ARGS
do
    if [ -z "$NAME_ARG" ]
    then
      continue
    fi
    if is_pattern "$NAME_ARG"
    then
      if MATCHES=$(expand_pattern_matches "$NAME_ARG" 2>/dev/null)
      then
        for SCRIPT_CANDIDATE in $MATCHES
        do
          if ! list_contains "$TO_INSTALL" "$SCRIPT_CANDIDATE"
          then
            TO_INSTALL="$TO_INSTALL $SCRIPT_CANDIDATE"
          fi
        done
        continue
      else
        echo "unknown tool pattern '$NAME_ARG'" >&2
        exit 2
      fi
    fi
    if SCRIPT_MATCH=$(resolve_name "$NAME_ARG" 2>/dev/null)
    then
      if ! list_contains "$TO_INSTALL" "$SCRIPT_MATCH"
      then
        TO_INSTALL="$TO_INSTALL $SCRIPT_MATCH"
      fi
    else
      echo "unknown tool '$NAME_ARG'" >&2
      exit 2
    fi
  done
else
  TO_INSTALL="$AVAILABLE_SCRIPTS"
fi

INSTALLED_COUNT=0
REMOVED_COUNT=0
for SCRIPT_PATH in $TO_INSTALL
do
  if list_contains "$IGNORE_SCRIPTS" "$SCRIPT_PATH"
then
    continue
  fi
  BASE_NAME=${SCRIPT_PATH##*/}
  DEST_NAME=$BASE_NAME
  if [ "$EMULATE" = true ]
then
    if [ "$BASE_NAME" != "poor-installer" ]
    then
      STRIPPED_NAME=${DEST_NAME#poor}
      if [ -n "$STRIPPED_NAME" ]
      then
        DEST_NAME=$STRIPPED_NAME
      fi
    fi
  fi
  DEST_PATH="$DEST/$DEST_NAME"
  if [ "$UNINSTALL" = true ]
then
    if [ -e "$DEST_PATH" ]
    then
      rm -f "$DEST_PATH"
      echo "removed $DEST_PATH"
      REMOVED_COUNT=$((REMOVED_COUNT + 1))
    else
      echo "warning: not found $DEST_PATH" >&2
    fi
  else
    if [ "$BASE_NAME" = "poor-installer" ]
    then
      if ln -sf "$SOURCE_DIR/$SCRIPT_PATH" "$DEST_PATH" 2>/dev/null
      then
        echo "$SCRIPT_PATH -> $DEST_PATH"
        INSTALLED_COUNT=$((INSTALLED_COUNT + 1))
        continue
      fi
    fi
    cp "$SCRIPT_PATH" "$DEST_PATH"
    chmod +x "$DEST_PATH"
    echo "$SCRIPT_PATH -> $DEST_PATH"
    INSTALLED_COUNT=$((INSTALLED_COUNT + 1))
  fi
done

if [ "$UNINSTALL" = true ]
then
  if [ "$REMOVED_COUNT" -eq 0 ]
then
    echo "nothing removed" >&2
  fi
  if [ "$CLEAR_DEST" = true ]
then
    if ! rmdir "$DEST" 2>/dev/null
    then
      echo "warning: could not remove '$DEST' (not empty?)" >&2
    fi
  fi
else
  if [ "$INSTALLED_COUNT" -eq 0 ]
then
    echo "nothing installed" >&2
  fi
fi
