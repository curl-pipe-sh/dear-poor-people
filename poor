#!/usr/bin/env sh
# poor — busybox-style multiplexer for poor-tools
# description: busybox-style multiplexer for poor-tools
# version: <GIT_COMMIT_SHA>
# icon: mdi:toolbox

set -eu

# Source shared libraries - these lines get replaced during templating
# shellcheck disable=SC1091  # File is included via templating
. lib/utils.sh # <TEMPLATE>
# shellcheck disable=SC1091  # File is included via templating
. lib/echo.sh # <TEMPLATE>
# shellcheck disable=SC1091  # File is included via templating
. lib/download.sh # <TEMPLATE>

# shellcheck disable=SC2034  # Used by echo.sh functions
SCRIPT_NAME="poor"

usage() {
  cat <<USAGE >&2
Usage:
  ${SCRIPT_NAME} [--debug] [--trace] TOOL [ARGS...]
  ${SCRIPT_NAME} install [OPTIONS] [TOOL...]
  ${SCRIPT_NAME} uninstall [OPTIONS] [TOOL...]
  ${SCRIPT_NAME} list [OPTIONS]
  ${SCRIPT_NAME} self-update [--force]
  curl -sSL <BASE_URL>/${SCRIPT_NAME} | sh -s -- TOOL [ARGS...]

Run poor-tools without installing each script. Behaves a bit like busybox:
  - "${SCRIPT_NAME} curl ..." runs poorcurl
  - Symlink ${SCRIPT_NAME} to "curl" so running "curl" executes ${SCRIPT_NAME} curl
  - "${SCRIPT_NAME} install --dest ~/.local/bin" installs poor-tools

Commands:
  install             Install poor-tools into a directory
  uninstall           Remove poor-tools from a directory
  list                List available poor-tools with installation status
  self-update         Update the poor script itself

Options:
  --debug             Enable debug output
  --trace             Enable shell tracing (set -x)
  -h, --help          Show this help

Environment:
  POOR_BASE_URL       Override the server or directory to fetch tools from
  POOR_TOOL_DIR       Directory containing already downloaded poor* scripts
  POOR_CACHE_DIR      Cache directory for downloaded scripts
  POOR_DOWNLOADER     Force downloader (curl or wget)
  POOR_REFRESH        If set to 1, always redownload before running
  POOR_NO_CACHE       If set to 1, do not reuse cached downloads
USAGE
}

ensure_cache_dir() {
  if [ -n "${POOR_CACHE_DIR-}" ]
  then
    CACHE_DIR=$POOR_CACHE_DIR
  else
    if [ -n "${XDG_CACHE_HOME-}" ]
    then
      CACHE_DIR=$XDG_CACHE_HOME/poor-tools
    else
      if [ -n "${HOME-}" ]
      then
        CACHE_DIR=$HOME/.cache/poor-tools
      else
        CACHE_DIR=${TMPDIR:-/tmp}/poor-tools-cache
      fi
    fi
  fi

  mkdir -p "$CACHE_DIR"
  printf '%s' "$CACHE_DIR"
}

strip_trailing_slash() {
  VALUE=$1
  case "$VALUE" in
    */)
      printf '%s' "${VALUE%/}"
      ;;
    *)
      printf '%s' "$VALUE"
      ;;
  esac
}

get_current_version() {
  # Try environment variable first (for containers/packages)
  if [ -n "${POOR_TOOLS_VERSION:-}" ]
  then
    printf '%s' "$POOR_TOOLS_VERSION"
    return 0
  fi

  # Try git short SHA from current directory or SCRIPT_DIR
  for GIT_DIR in "${SCRIPT_DIR:-}" "."
  do
    if [ -n "$GIT_DIR" ] && { [ -d "$GIT_DIR/.git" ] || [ -f "$GIT_DIR/.git" ]; }
    then
      if GIT_SHA=$(cd "$GIT_DIR" && git rev-parse --short HEAD 2>/dev/null)
      then
        printf '%s' "$GIT_SHA"
        return 0
      fi
    fi
  done

  # Fallback: Extract version from our own script header if it's been templated
  if [ -n "${SELF_VERSION:-}" ]
  then
    printf '%s' "$SELF_VERSION"
    return 0
  fi

  # Last resort fallback
  printf 'unknown'
}

apply_templating() {
  SOURCE_FILE="$1"
  DEST_FILE="$2"

  # Check if the file is already templated (downloaded from web server)
  if ! grep -q "<GIT_COMMIT_SHA>" "$SOURCE_FILE" 2>/dev/null
  then
    # File is already templated by web server, just copy it
    cp "$SOURCE_FILE" "$DEST_FILE"
    return 0
  fi

  # Get current version for templating
  CURRENT_VERSION=$(get_current_version)

  # Apply templating: replace <GIT_COMMIT_SHA> with actual version
  sed "s/<GIT_COMMIT_SHA>/$CURRENT_VERSION/g" "$SOURCE_FILE" > "$DEST_FILE"
}

build_cache_path() {
  CACHE_DIR=$(ensure_cache_dir)
  TARGET=$1
  printf '%s/%s' "$CACHE_DIR" "$TARGET"
}

trap_cleanup_prepare() {
  if [ "${TRAP_INSTALLED-}" = "1" ]
  then
    return
  fi

  TRAP_INSTALLED=1
  trap 'cleanup_tmp "$TMP_DOWNLOAD"' EXIT INT TERM
}

cleanup_tmp() {
  TMP_FILE=$1
  if [ -n "$TMP_FILE" ] && [ -f "$TMP_FILE" ]
  then
    rm -f "$TMP_FILE"
  fi
}

finalize_download() {
  TMP_FILE=$1
  DEST_PATH=$2
  EXEC_FLAG=$3

  mv "$TMP_FILE" "$DEST_PATH"
  if [ "$EXEC_FLAG" = "1" ]
  then
    chmod 755 "$DEST_PATH"
  else
    chmod 644 "$DEST_PATH"
  fi
}

run_downloader() {
  URL=$1
  DEST_PATH=$2
  EXEC_FLAG=$3

  DOWNLOADER=$(select_downloader_impl) || return 1

  DEST_DIR=$(dirname "$DEST_PATH")
  mkdir -p "$DEST_DIR"

  TMP_DOWNLOAD=${DEST_PATH}.tmp.$$
  trap_cleanup_prepare

  : > "$TMP_DOWNLOAD"

  if download_file_impl "$URL" "$TMP_DOWNLOAD" "$DOWNLOADER"
  then
    finalize_download "$TMP_DOWNLOAD" "$DEST_PATH" "$EXEC_FLAG"
    TMP_DOWNLOAD=""
    return 0
  fi

  cleanup_tmp "$TMP_DOWNLOAD"
  TMP_DOWNLOAD=""
  return 1
}

download_from_base() {
  DEST_PATH=$1
  EXEC_FLAG=$2
  REMOTE_PATH=$3

  case "$BASE_URL" in
    *://*)
      BASE=$(strip_trailing_slash "$BASE_URL")
      URL=$BASE/$REMOTE_PATH
      if run_downloader "$URL" "$DEST_PATH" "$EXEC_FLAG"
      then
        return 0
      fi
      ;;
    *)
      SOURCE_DIR=$(strip_trailing_slash "$BASE_URL")
      SOURCE_PATH=$SOURCE_DIR/$REMOTE_PATH
      if [ -f "$SOURCE_PATH" ]
      then
        DEST_DIR=$(dirname "$DEST_PATH")
        mkdir -p "$DEST_DIR"

        # Apply templating to replace placeholders like <GIT_COMMIT_SHA>
        apply_templating "$SOURCE_PATH" "$DEST_PATH"

        if [ "$EXEC_FLAG" = "1" ]
        then
          chmod 755 "$DEST_PATH"
        else
          chmod 644 "$DEST_PATH"
        fi
        return 0
      fi
      ;;
  esac

  return 1
}

download_candidates() {
  DEST_PATH=$1
  EXEC_FLAG=$2
  shift
  shift

  while [ $# -gt 0 ]
  do
    REMOTE_PATH=$1
    shift
    if download_from_base "$DEST_PATH" "$EXEC_FLAG" "$REMOTE_PATH"
    then
      return 0
    fi
  done

  return 1
}

find_dependencies() {
  SCRIPT_FILE=$1
  (
    while IFS= read -r LINE
    do
      case "$LINE" in
        *"# <TEMPLATE>"*)
          # shellcheck disable=SC2086
          set -- $LINE
          if [ $# -ge 2 ]
          then
            FIRST_WORD=$1
            SECOND_WORD=$2
            if [ "$FIRST_WORD" = "." ] || [ "$FIRST_WORD" = "source" ]
            then
              case "$SECOND_WORD" in
                lib/*)
                  printf '%s\n' "$SECOND_WORD"
                  ;;
              esac
            fi
          fi
          ;;
      esac
    done < "$SCRIPT_FILE"
  )
}

ensure_dependencies() {
  SCRIPT_FILE=$1
  DEPENDENCIES=$(find_dependencies "$SCRIPT_FILE")
  if [ -z "$DEPENDENCIES" ]
  then
    return 0
  fi

  SCRIPT_DIRNAME=$(dirname "$SCRIPT_FILE")

  for DEP in $DEPENDENCIES
  do
    TARGET_PATH=$SCRIPT_DIRNAME/$DEP
    if [ -f "$TARGET_PATH" ]
    then
      continue
    fi

    if download_candidates "$TARGET_PATH" 0 "$DEP"
    then
      ensure_dependencies "$TARGET_PATH"
      continue
    fi

    echo_error "poor: failed to fetch dependency $DEP"
    return 1
  done

  return 0
}

# Functions from poor-installer for installation functionality
list_contains() {
  LIST="$1"
  NEEDLE="$2"
  for ENTRY in $LIST
  do
    if [ "$ENTRY" = "$NEEDLE" ]
    then
      return 0
    fi
  done
  return 1
}

is_pattern() {
  case "$1" in
    *\**|*\?*|*\[*|*\]*)
      return 0
      ;;
  esac
  return 1
}

matches_pattern() {
  VALUE="$1"
  PATTERN="$2"
  # shellcheck disable=SC2254 # PATTERN is intended to be a glob pattern
  case "$VALUE" in
    $PATTERN)
      return 0
      ;;
  esac
  return 1
}

resolve_install_name() {
  TARGET="$1"
  for SCRIPT_CANDIDATE in $AVAILABLE_SCRIPTS
  do
    BASE_NAME="${SCRIPT_CANDIDATE##*/}"
    ALT_NAME="${BASE_NAME#poor}"
    ALT_NAME="${ALT_NAME#-}"
    if [ "$TARGET" = "$BASE_NAME" ] || [ "$TARGET" = "$ALT_NAME" ]
    then
      echo "$SCRIPT_CANDIDATE"
      return 0
    fi
  done
  return 1
}

expand_pattern_matches() {
  PATTERN="$1"
  RESULTS=""
  for SCRIPT_CANDIDATE in $AVAILABLE_SCRIPTS
  do
    BASE_NAME="${SCRIPT_CANDIDATE##*/}"
    ALT_NAME="${BASE_NAME#poor}"
    ALT_NAME="${ALT_NAME#-}"
    if matches_pattern "$BASE_NAME" "$PATTERN" || matches_pattern "$ALT_NAME" "$PATTERN"
    then
      RESULTS="$RESULTS $SCRIPT_CANDIDATE"
    fi
  done
  if [ -n "$RESULTS" ]
  then
    echo "$RESULTS"
    return 0
  fi
  return 1
}

initialize_install_source_directory() {
  # Ensure we run from the directory containing the script so we can find the tools
  SCRIPT_PATH="$0"
  if [ "${SCRIPT_PATH%/*}" = "$SCRIPT_PATH" ]
  then
    SCRIPT_PATH=$(command -v -- "$SCRIPT_PATH" 2>/dev/null || echo "$SCRIPT_PATH")
  fi
  while LINK_TARGET=$(readlink "$SCRIPT_PATH" 2>/dev/null)
  do
    case "$LINK_TARGET" in
      /*)
        SCRIPT_PATH="${LINK_TARGET}"
        ;;
      *)
        SCRIPT_DIRNAME=$(dirname -- "$SCRIPT_PATH")
        SCRIPT_PATH="${SCRIPT_DIRNAME}/${LINK_TARGET}"
        ;;
    esac
  done
  SCRIPT_DIR=$(CDPATH='' cd -- "$(dirname -- "$SCRIPT_PATH")" && pwd -P)
  INSTALL_SOURCE_DIR="${SCRIPT_DIR}"
  cd "$INSTALL_SOURCE_DIR"
}

# Check for unmanaged files in destination directory
check_unmanaged_files() {
  dest_dir="$1"
  available_tools="$2"  # Space-separated list of known tools

  if [ ! -d "$dest_dir" ]
  then
    return 0  # Directory doesn't exist, nothing to check
  fi

  # Create a list of expected poor-tool files (including variants)
  expected_files=""
  for tool in $available_tools
  do
    # Add the tool itself
    expected_files="$expected_files $tool"

    # Add emulated version (without poor prefix)
    case "$tool" in
      poor*)
        stripped_name="${tool#poor}"
        if [ -n "$stripped_name" ]
        then
          expected_files="$expected_files $stripped_name"
        fi
        ;;
    esac
  done

  # Find files that don't match any expected poor-tool
  unmanaged_files=""
  for file in "$dest_dir"/*
  do
    if [ ! -e "$file" ]  # Handle case when glob doesn't match anything
    then
      continue
    fi

    filename=$(basename "$file")

    # Skip if it's a directory
    if [ -d "$file" ]
    then
      unmanaged_files="$unmanaged_files $filename"
      continue
    fi

    # Check if this file is in our expected list
    is_managed=0
    for expected in $expected_files
    do
      if [ "$filename" = "$expected" ]
      then
        is_managed=1
        break
      fi
    done

    if [ "$is_managed" = 0 ]
    then
      unmanaged_files="$unmanaged_files $filename"
    fi
  done

  if [ -n "$unmanaged_files" ]
  then
    echo_error "Found unmanaged files in $dest_dir:"
    for file in $unmanaged_files
    do
      echo "  $file"
    done
    echo ""
    echo_error "Refusing to clear directory with unmanaged files."
    echo_info "Options:"
    echo_info "  1. Remove unmanaged files manually"
    echo_info "  2. Use --force to force removal of all files"
    echo_info "  3. Use a different destination directory"
    return 1
  fi

  return 0
}

handle_install_command() {
  shift  # remove "install" from arguments

  # Initialize variables for install functionality
  TARGET_DEST=""
  EMULATE=""
  IGNORE_ARGS=""
  CLEAR_DEST=""
  FORCE_CLEAR=""
  UNINSTALL=""

  # Parse install options
  while [ $# -gt 0 ]
  do
    case "$1" in
      --dest)
        shift
        if [ $# -eq 0 ]
        then
          echo_error "option '--dest' requires an argument"
          usage_install
          return 2
        fi
        TARGET_DEST="$1"
        shift
        ;;
      --dest=*)
        TARGET_DEST="${1#--dest=}"
        shift
        ;;
      --emulate)
        EMULATE=1
        shift
        ;;
      --clear)
        CLEAR_DEST=1
        shift
        ;;
      --force)
        FORCE_CLEAR=1
        shift
        ;;
      --uninstall)
        UNINSTALL=1
        shift
        ;;
      --ignore|--skip)
        OPTION_NAME="$1"
        shift
        if [ $# -eq 0 ]
        then
          echo_error "option '$OPTION_NAME' requires an argument"
          usage_install
          return 2
        fi
        IGNORE_ARGS="$IGNORE_ARGS $1"
        shift
        ;;
      --ignore=*|--skip=*)
        OPTION_VALUE="${1#*=}"
        IGNORE_ARGS="$IGNORE_ARGS $OPTION_VALUE"
        shift
        ;;
      -h|--help)
        usage_install
        return 0
        ;;
      --)
        shift
        break
        ;;
      -*)
        echo_error "unknown option '$1'"
        usage_install
        return 2
        ;;
      *)
        break
        ;;
    esac
  done

  # Collect remaining arguments for tool selection
  SELECT_ARGS=""
  while [ $# -gt 0 ]
  do
    SELECT_ARGS="$SELECT_ARGS $1"
    shift
  done

  # Validate destination - check command line arg first, then environment variable, then default
  if [ -z "$TARGET_DEST" ] && [ -n "${DEST:-}" ]
  then
    TARGET_DEST="$DEST"
  fi

  if [ -z "$TARGET_DEST" ]
  then
    TARGET_DEST="$HOME/.local/bin"
    echo_info "Using default destination: $TARGET_DEST"
  fi

  # Setup destination directory
  if [ -n "$UNINSTALL" ]
  then
    if [ ! -d "$TARGET_DEST" ]
    then
      echo "destination '$TARGET_DEST' does not exist, nothing to uninstall" >&2
      return 0
    fi
  else
    mkdir -p "$TARGET_DEST"
    # Defer clearing until after we know what tools are available
  fi

  # Initialize source directory and find available scripts
  USE_REMOTE_TOOLS=""
  if ! initialize_install_source_directory 2>/dev/null
  then
    # Not in a git repo or local source directory, use remote tools only
    USE_REMOTE_TOOLS=1
    echo_info "No local source directory found, using remote tools from $BASE_URL"
  fi

  AVAILABLE_SCRIPTS=""
  if [ -z "$USE_REMOTE_TOOLS" ]
  then
    for SCRIPT_PATH_CANDIDATE in poor*
    do
      if [ -f "$SCRIPT_PATH_CANDIDATE" ]
      then
        AVAILABLE_SCRIPTS="$AVAILABLE_SCRIPTS $SCRIPT_PATH_CANDIDATE"
      fi
    done
  fi

  # If no local tools found, try to get remote tools
  if [ -z "$AVAILABLE_SCRIPTS" ]
  then
    echo_info "No local tools found, fetching tool list from remote server..."
    REMOTE_TOOLS=$(get_remote_tools 2>/dev/null || true)
    if [ -n "$REMOTE_TOOLS" ]
    then
      # Filter out non-tool lines (comments, empty lines, etc.)
      FILTERED_TOOLS=""
      while IFS= read -r tool_line
      do
        # Skip empty lines and comments
        if [ -n "$tool_line" ] && [ "${tool_line#\#}" = "$tool_line" ]
        then
          # Only include lines that look like tool names (poor* or known tool names)
          case "$tool_line" in
            poor*|column|curl|curl-openssl|nmap|socat|timeout)
              FILTERED_TOOLS="$FILTERED_TOOLS $tool_line"
              ;;
          esac
        fi
      done <<EOF
$REMOTE_TOOLS
EOF

      if [ -n "$FILTERED_TOOLS" ]
      then
        AVAILABLE_SCRIPTS="$FILTERED_TOOLS"
        USE_REMOTE_TOOLS=1
        echo_info "Found $(echo "$AVAILABLE_SCRIPTS" | wc -w) tools on remote server"
      else
        echo_warning "Remote server returned data but no valid tools found"
        echo_debug "Raw response: $REMOTE_TOOLS"
      fi
    else
      echo_warning "No response from remote server"
    fi
  fi

  # Now that we know available tools, handle clearing with safety checks
  if [ -n "$CLEAR_DEST" ] && [ -d "$TARGET_DEST" ] && [ -z "$UNINSTALL" ]
  then
    echo_info "Clearing destination directory: $TARGET_DEST"

    # Check for unmanaged files unless --force is used
    if [ -z "$FORCE_CLEAR" ]
    then
      if ! check_unmanaged_files "$TARGET_DEST" "$AVAILABLE_SCRIPTS"
      then
        echo_error "Aborting due to unmanaged files in destination directory."
        return 1
      fi
    fi

    # Safe to clear now
    find "$TARGET_DEST" -mindepth 1 -maxdepth 1 -exec rm -rf {} + 2>/dev/null || true
    echo_success "Cleared $TARGET_DEST"
  fi

  if [ -z "$AVAILABLE_SCRIPTS" ]
  then
    echo_error "No tools found locally or remotely. Please check your BASE_URL: $BASE_URL"
    return 1
  fi

  # Process ignore patterns
  IGNORE_SCRIPTS=""
  for NAME_ARG in $IGNORE_ARGS
  do
    if [ -z "$NAME_ARG" ]
    then
      continue
    fi
    if is_pattern "$NAME_ARG"
    then
      if MATCHES=$(expand_pattern_matches "$NAME_ARG" 2>/dev/null)
      then
        for SCRIPT_CANDIDATE in $MATCHES
        do
          if ! list_contains "$IGNORE_SCRIPTS" "$SCRIPT_CANDIDATE"
          then
            IGNORE_SCRIPTS="$IGNORE_SCRIPTS $SCRIPT_CANDIDATE"
          fi
        done
        continue
      else
        echo_warning "no tool matches pattern '${NAME_ARG}'"
        continue
      fi
    fi
    if SCRIPT_MATCH=$(resolve_install_name "$NAME_ARG" 2>/dev/null)
    then
      if ! list_contains "$IGNORE_SCRIPTS" "$SCRIPT_MATCH"
      then
        IGNORE_SCRIPTS="$IGNORE_SCRIPTS $SCRIPT_MATCH"
      fi
    else
      echo_warning "no tool matches '${NAME_ARG}'"
    fi
  done

  # Process tool selection
  TO_INSTALL=""
  if [ -n "$SELECT_ARGS" ]
  then
    for NAME_ARG in $SELECT_ARGS
    do
      if [ -z "$NAME_ARG" ]
      then
        continue
      fi
      if is_pattern "$NAME_ARG"
      then
        if MATCHES=$(expand_pattern_matches "$NAME_ARG" 2>/dev/null)
        then
          for SCRIPT_CANDIDATE in $MATCHES
          do
            if ! list_contains "$TO_INSTALL" "$SCRIPT_CANDIDATE"
            then
              TO_INSTALL="$TO_INSTALL $SCRIPT_CANDIDATE"
            fi
          done
          continue
        else
          echo "unknown tool pattern '$NAME_ARG'" >&2
          return 2
        fi
      fi
      if SCRIPT_MATCH=$(resolve_install_name "$NAME_ARG" 2>/dev/null)
      then
        if ! list_contains "$TO_INSTALL" "$SCRIPT_MATCH"
        then
          TO_INSTALL="$TO_INSTALL $SCRIPT_MATCH"
        fi
      else
        echo "unknown tool '$NAME_ARG'" >&2
        return 2
      fi
    done
  else
    TO_INSTALL="$AVAILABLE_SCRIPTS"
  fi

  # Perform installation/uninstallation
  INSTALLED_COUNT=0
  REMOVED_COUNT=0
  for SCRIPT_PATH in $TO_INSTALL
  do
    if list_contains "$IGNORE_SCRIPTS" "$SCRIPT_PATH"
    then
      continue
    fi
    BASE_NAME="${SCRIPT_PATH##*/}"
    DEST_NAME="$BASE_NAME"
    if [ -n "$EMULATE" ]
    then
      if [ "$BASE_NAME" != "poor" ]
      then
        STRIPPED_NAME="${DEST_NAME#poor}"
        if [ -n "$STRIPPED_NAME" ]
        then
          DEST_NAME="$STRIPPED_NAME"
        fi
      fi
    fi
    DEST_PATH="$TARGET_DEST/$DEST_NAME"
    if [ -n "$UNINSTALL" ]
    then
      if [ -e "$DEST_PATH" ]
      then
        rm -f "$DEST_PATH"
        echo "removed $DEST_PATH"
        REMOVED_COUNT=$((REMOVED_COUNT + 1))
      else
        echo "warning: not found $DEST_PATH" >&2
      fi
    else
      if [ "$BASE_NAME" = "poor" ]
      then
        if [ -z "$USE_REMOTE_TOOLS" ] && ln -sf "$INSTALL_SOURCE_DIR/$SCRIPT_PATH" "$DEST_PATH" 2>/dev/null
        then
          echo "$SCRIPT_PATH -> $DEST_PATH"
          INSTALLED_COUNT=$((INSTALLED_COUNT + 1))
          continue
        fi
      fi

      # Handle remote or local tool installation
      if [ -n "$USE_REMOTE_TOOLS" ]
      then
        # Download tool from remote server
        if download_candidates "$DEST_PATH" 1 "$SCRIPT_PATH"
        then
          echo "$SCRIPT_PATH -> $DEST_PATH (downloaded from $BASE_URL)"
          INSTALLED_COUNT=$((INSTALLED_COUNT + 1))
        else
          echo_error "Failed to download $SCRIPT_PATH from $BASE_URL"
        fi
      else
        # Use local file with templating
        apply_templating "$SCRIPT_PATH" "$DEST_PATH"
        chmod +x "$DEST_PATH"
        echo "$SCRIPT_PATH -> $DEST_PATH"
        INSTALLED_COUNT=$((INSTALLED_COUNT + 1))
      fi
    fi
  done

  if [ -n "$UNINSTALL" ]
  then
    if [ "$REMOVED_COUNT" -eq 0 ]
    then
      echo "nothing removed" >&2
    else
      echo_success "Successfully removed $REMOVED_COUNT tool(s) from $TARGET_DEST"
    fi
    if [ -n "$CLEAR_DEST" ]
    then
      if [ -n "$FORCE_CLEAR" ]
      then
        # Force removal of directory and all contents
        echo_info "Force removing directory: $TARGET_DEST"
        rm -rf "$TARGET_DEST"
        echo_success "Removed directory $TARGET_DEST"
      else
        # Try to remove only if empty
        if ! rmdir "$TARGET_DEST" 2>/dev/null
        then
          echo "warning: could not remove '$TARGET_DEST' (not empty)" >&2
          echo_info "Use --force to remove directory with remaining contents"
        else
          echo_success "Removed empty directory $TARGET_DEST"
        fi
      fi
    fi
  else
    if [ "$INSTALLED_COUNT" -eq 0 ]
    then
      echo "nothing installed" >&2
    else
      echo_success "Successfully installed $INSTALLED_COUNT tool(s) to $TARGET_DEST"

      # Check if destination is in PATH
      case ":$PATH:" in
        *":$TARGET_DEST:"*)
          echo_success "$TARGET_DEST is in your PATH"
          ;;
        *)
          echo_warning "$TARGET_DEST is not in your PATH -> export PATH=\"$TARGET_DEST:\$PATH\""
          ;;
      esac

      # Show uninstall command
      echo_info -n "To uninstall, run: "

      # Check if poor was installed in the destination directory
      POOR_INSTALLED=""
      if [ -f "$TARGET_DEST/poor" ]
      then
        POOR_INSTALLED="$TARGET_DEST/poor"
      fi

      if [ -n "$POOR_INSTALLED" ]
      then
        echo "$POOR_INSTALLED uninstall --clear --dest \"$TARGET_DEST\""
      else
        echo "curl $(strip_trailing_slash "$BASE_URL") | sh -s -- uninstall --clear --dest \"$TARGET_DEST\""
      fi
    fi
  fi
}

usage_install() {
  cat <<USAGE_INSTALL >&2
Usage: ${SCRIPT_NAME} install [OPTIONS] [TOOL...]

Install poor-tools into a destination directory.

Options:
  --dest DIR       Install into DIR (default: ~/.local/bin)
  --emulate        Strip leading "poor" when naming installed binaries
  --clear          Remove DEST before install (fails if unmanaged files found)
  --force          Force removal of DEST even with unmanaged files (use with --clear)
  --uninstall      Remove matching files instead of installing
  --ignore NAME    Skip a tool (repeatable, accepts NAME or poorNAME)
  --skip NAME      Alias for --ignore
  -h, --help       Show this help

If TOOL arguments are provided, only those tools are installed. Otherwise all
available poor* scripts are copied.
USAGE_INSTALL
}

usage_uninstall() {
  cat <<USAGE_UNINSTALL >&2
Usage: ${SCRIPT_NAME} uninstall [OPTIONS] [TOOL...]

Remove poor-tools from a destination directory.

Options:
  --dest DIR       Remove from DIR (default: ~/.local/bin)
  --emulate        Strip leading "poor" when looking for installed binaries
  --clear          Remove DEST directory after uninstall (if empty, or --force)
  --force          Force removal of DEST even if not empty (use with --clear)
  --ignore NAME    Skip a tool (repeatable, accepts NAME or poorNAME)
  --skip NAME      Alias for --ignore
  -h, --help       Show this help

If TOOL arguments are provided, only those tools are removed. Otherwise all
available poor* scripts are removed from the destination.

Examples:
  ${SCRIPT_NAME} uninstall --dest ~/.local/bin
  ${SCRIPT_NAME} uninstall --dest /usr/local/bin poorcurl poornmap
  ${SCRIPT_NAME} uninstall --emulate --dest ~/.local/bin curl nmap
USAGE_UNINSTALL
}

usage_list() {
  cat <<USAGE_LIST >&2
Usage: ${SCRIPT_NAME} list [OPTIONS]

List available poor-tools with installation status and version information.

Options:
  --dest DIR         Check installation status in DIR (or set DEST environment variable)
  --emulate          Check for tools without "poor" prefix when checking installation
  --local            Only show locally available tools (don't check remote)
  --remote           Only show remotely available tools (don't check local)
  --installed        Only show installed tools
  --available        Only show non-installed tools
  --no-check-updates Disable version checking and update detection
  -h, --help         Show this help

Shows a list of all poor-tools with checkmarks (✅) for installed tools.
By default shows version info and marks out-of-date tools with (⚠️).

Examples:
  ${SCRIPT_NAME} list                                   # List all available tools with versions
  ${SCRIPT_NAME} list --dest ~/.local/bin               # Check installation in specific dir
  ${SCRIPT_NAME} list --emulate --dest ~/.local/bin     # Check emulated installations
  ${SCRIPT_NAME} list --installed                       # Only show installed tools
  ${SCRIPT_NAME} list --no-check-updates                # List without version information
  ${SCRIPT_NAME} list --local                           # Only show locally available tools
USAGE_LIST
}

handle_uninstall_command() {
  shift  # remove "uninstall" from arguments

  # Initialize variables for uninstall functionality
  TARGET_DEST=""
  EMULATE=""
  IGNORE_ARGS=""
  CLEAR_DEST=""
  FORCE_CLEAR=""

  # Parse uninstall options
  while [ $# -gt 0 ]
  do
    case "$1" in
      --dest)
        shift
        if [ $# -eq 0 ]
        then
          echo_error "option '--dest' requires an argument"
          usage_uninstall
          return 2
        fi
        TARGET_DEST="$1"
        shift
        ;;
      --dest=*)
        TARGET_DEST="${1#--dest=}"
        shift
        ;;
      --emulate)
        EMULATE=1
        shift
        ;;
      --clear)
        CLEAR_DEST=1
        shift
        ;;
      --force)
        FORCE_CLEAR=1
        shift
        ;;
      --ignore|--skip)
        OPTION_NAME="$1"
        shift
        if [ $# -eq 0 ]
        then
          echo_error "option '$OPTION_NAME' requires an argument"
          usage_uninstall
          return 2
        fi
        IGNORE_ARGS="$IGNORE_ARGS $1"
        shift
        ;;
      --ignore=*|--skip=*)
        OPTION_VALUE="${1#*=}"
        IGNORE_ARGS="$IGNORE_ARGS $OPTION_VALUE"
        shift
        ;;
      -h|--help)
        usage_uninstall
        return 0
        ;;
      --)
        shift
        break
        ;;
      -*)
        echo_error "unknown option '$1'"
        usage_uninstall
        return 2
        ;;
      *)
        break
        ;;
    esac
  done

  # Collect remaining arguments for tool selection
  SELECT_ARGS=""
  while [ $# -gt 0 ]
  do
    SELECT_ARGS="$SELECT_ARGS $1"
    shift
  done

  # Validate destination - check command line arg first, then environment variable, then default
  if [ -z "$TARGET_DEST" ] && [ -n "${DEST:-}" ]
  then
    TARGET_DEST="$DEST"
  fi

  if [ -z "$TARGET_DEST" ]
  then
    TARGET_DEST="$HOME/.local/bin"
    echo_info "Using default destination: $TARGET_DEST"
  fi

  # Check if destination exists
  if [ ! -d "$TARGET_DEST" ]
  then
    echo "destination '$TARGET_DEST' does not exist, nothing to uninstall" >&2
    return 0
  fi

  # Initialize source directory and find available scripts
  if ! initialize_install_source_directory 2>/dev/null
  then
    # Not in a git repo or local source directory, use remote tools for tool names
    echo_info "No local source directory found, using remote tools for uninstall from $BASE_URL"
  fi

  AVAILABLE_SCRIPTS=""
  for SCRIPT_PATH_CANDIDATE in poor*
  do
    if [ -f "$SCRIPT_PATH_CANDIDATE" ]
    then
      AVAILABLE_SCRIPTS="$AVAILABLE_SCRIPTS $SCRIPT_PATH_CANDIDATE"
    fi
  done

  # If no local tools found, try to get remote tools for tool name resolution
  if [ -z "$AVAILABLE_SCRIPTS" ]
  then
    echo_info "No local tools found, fetching tool list from remote server for name resolution..."
    REMOTE_TOOLS=$(get_remote_tools 2>/dev/null || true)
    if [ -n "$REMOTE_TOOLS" ]
    then
      AVAILABLE_SCRIPTS=$(printf '%s' "$REMOTE_TOOLS" | tr '\n' ' ')
      echo_info "Found $(echo "$AVAILABLE_SCRIPTS" | wc -w) tools on remote server"
    fi
  fi

  if [ -z "$AVAILABLE_SCRIPTS" ]
  then
    echo_error "No tools found locally or remotely for name resolution. Please check your BASE_URL: $BASE_URL"
    return 1
  fi

  # Process ignore patterns
  IGNORE_SCRIPTS=""
  for NAME_ARG in $IGNORE_ARGS
  do
    if [ -z "$NAME_ARG" ]
    then
      continue
    fi
    if is_pattern "$NAME_ARG"
    then
      if MATCHES=$(expand_pattern_matches "$NAME_ARG" 2>/dev/null)
      then
        for SCRIPT_CANDIDATE in $MATCHES
        do
          if ! list_contains "$IGNORE_SCRIPTS" "$SCRIPT_CANDIDATE"
          then
            IGNORE_SCRIPTS="$IGNORE_SCRIPTS $SCRIPT_CANDIDATE"
          fi
        done
        continue
      else
        echo_warning "no tool matches pattern '${NAME_ARG}'"
        continue
      fi
    fi
    if SCRIPT_MATCH=$(resolve_install_name "$NAME_ARG" 2>/dev/null)
    then
      if ! list_contains "$IGNORE_SCRIPTS" "$SCRIPT_MATCH"
      then
        IGNORE_SCRIPTS="$IGNORE_SCRIPTS $SCRIPT_MATCH"
      fi
    else
      echo_warning "no tool matches '${NAME_ARG}'"
    fi
  done

  # Process tool selection
  TO_UNINSTALL=""
  if [ -n "$SELECT_ARGS" ]
  then
    for NAME_ARG in $SELECT_ARGS
    do
      if [ -z "$NAME_ARG" ]
      then
        continue
      fi
      if is_pattern "$NAME_ARG"
      then
        if MATCHES=$(expand_pattern_matches "$NAME_ARG" 2>/dev/null)
        then
          for SCRIPT_CANDIDATE in $MATCHES
          do
            if ! list_contains "$TO_UNINSTALL" "$SCRIPT_CANDIDATE"
            then
              TO_UNINSTALL="$TO_UNINSTALL $SCRIPT_CANDIDATE"
            fi
          done
          continue
        else
          echo "unknown tool pattern '$NAME_ARG'" >&2
          return 2
        fi
      fi
      if SCRIPT_MATCH=$(resolve_install_name "$NAME_ARG" 2>/dev/null)
      then
        if ! list_contains "$TO_UNINSTALL" "$SCRIPT_MATCH"
        then
          TO_UNINSTALL="$TO_UNINSTALL $SCRIPT_MATCH"
        fi
      else
        echo "unknown tool '$NAME_ARG'" >&2
        return 2
      fi
    done
  else
    TO_UNINSTALL="$AVAILABLE_SCRIPTS"
  fi

  # Perform uninstallation
  REMOVED_COUNT=0
  for SCRIPT_PATH in $TO_UNINSTALL
  do
    if list_contains "$IGNORE_SCRIPTS" "$SCRIPT_PATH"
    then
      continue
    fi
    BASE_NAME="${SCRIPT_PATH##*/}"
    DEST_NAME="$BASE_NAME"
    if [ -n "$EMULATE" ]
    then
      if [ "$BASE_NAME" != "poor" ]
      then
        STRIPPED_NAME="${DEST_NAME#poor}"
        if [ -n "$STRIPPED_NAME" ]
        then
          DEST_NAME="$STRIPPED_NAME"
        fi
      fi
    fi
    DEST_PATH="$TARGET_DEST/$DEST_NAME"

    if [ -e "$DEST_PATH" ]
    then
      rm -f "$DEST_PATH"
      echo "removed $DEST_PATH"
      REMOVED_COUNT=$((REMOVED_COUNT + 1))
    else
      echo "warning: not found $DEST_PATH" >&2
    fi
  done

  if [ "$REMOVED_COUNT" -eq 0 ]
  then
    echo "nothing removed" >&2
  fi

  if [ -n "$CLEAR_DEST" ]
  then
    if [ -n "$FORCE_CLEAR" ]
    then
      # Force removal of directory and all contents
      echo_info "Force removing directory: $TARGET_DEST"
      rm -rf "$TARGET_DEST"
      echo_success "Removed directory $TARGET_DEST"
    else
      # Try to remove only if empty
      if ! rmdir "$TARGET_DEST" 2>/dev/null
      then
        echo "warning: could not remove '$TARGET_DEST' (not empty)" >&2
        echo_info "Use --force to remove directory with remaining contents"
      else
        echo_success "Removed empty directory $TARGET_DEST"
      fi
    fi
  fi
}

# Get tool description from script header
get_tool_description() {
  TOOL_FILE="$1"
  if [ -f "$TOOL_FILE" ]
  then
    DESC=$(grep "^# description:" "$TOOL_FILE" 2>/dev/null | head -1 | sed 's/^# description: *//')
    if [ -n "$DESC" ]
    then
      printf '%s' "$DESC"
      return 0
    fi
  fi
  return 1
}

# Get tool version from script header
get_tool_version() {
  TOOL_FILE="$1"
  if [ -f "$TOOL_FILE" ]
  then
    VERSION=$(grep "^# version:" "$TOOL_FILE" 2>/dev/null | head -1 | sed 's/^# version: *//')
    if [ -n "$VERSION" ]
    then
      printf '%s' "$VERSION"
      return 0
    fi
  fi
  return 1
}

# Get remote tools metadata as JSON
get_remote_tools_json() {
  REMOTE_JSON=""

  case "$BASE_URL" in
    *://*)
      # Try to get JSON list from web server
      DOWNLOADER=$(select_downloader_impl 2>/dev/null) || return 1
      JSON_URL=$(strip_trailing_slash "$BASE_URL")/list/json

      if [ "$DOWNLOADER" = "curl" ]
      then
        # Try with User-Agent header first, fall back to simple request
        REMOTE_JSON=$(curl -fsSL -H "User-Agent: poor" "$JSON_URL" 2>/dev/null || curl -fsSL "$JSON_URL" 2>/dev/null)
      elif [ "$DOWNLOADER" = "wget" ]
      then
        REMOTE_JSON=$(wget -qO- "$JSON_URL" 2>/dev/null)
      fi
      ;;
  esac

  printf '%s' "$REMOTE_JSON"
}

# Extract version from JSON for a specific tool
get_remote_tool_version() {
  TOOL_NAME="$1"
  JSON_DATA="$2"

  if [ -z "$JSON_DATA" ]
  then
    return 1
  fi

  # Simple JSON parsing - extract version for the specific tool
  # Handle both compact and pretty JSON formats
  TOOL_LINE=$(printf '%s' "$JSON_DATA" | grep -E "\"name\" *: *\"$TOOL_NAME\"" -A 5 2>/dev/null)
  if [ -n "$TOOL_LINE" ]
  then
    VERSION_LINE=$(printf '%s' "$TOOL_LINE" | grep -E "\"version\" *:" | head -1)
    if [ -n "$VERSION_LINE" ]
    then
      # Extract version value - handle both compact and pretty JSON
      VERSION=$(printf '%s' "$VERSION_LINE" | sed 's/.*"version" *: *"\([^"]*\)".*/\1/')
      if [ -n "$VERSION" ] && [ "$VERSION" != "$VERSION_LINE" ]
      then
        printf '%s' "$VERSION"
        return 0
      fi
    fi
  fi
  return 1
}

# Check if tool has updates available
has_tool_update() {
  TOOL_NAME="$1"
  LOCAL_VERSION="$2"
  REMOTE_JSON="$3"

  REMOTE_VERSION=$(get_remote_tool_version "$TOOL_NAME" "$REMOTE_JSON")
  if [ -n "$REMOTE_VERSION" ] && [ -n "$LOCAL_VERSION" ] && [ "$REMOTE_VERSION" != "$LOCAL_VERSION" ] && [ "$LOCAL_VERSION" != "unknown" ]
  then
    return 0  # Update available (versions differ)
  fi
  return 1  # No update available or no version info
}

# Get available tools from remote source
get_remote_tools() {
  REMOTE_LIST=""

  case "$BASE_URL" in
    *://*)
      # Try to get list from web server
      DOWNLOADER=$(select_downloader_impl 2>/dev/null) || return 1
      LIST_URL=$(strip_trailing_slash "$BASE_URL")/list

      if [ "$DOWNLOADER" = "curl" ]
      then
        # Try with User-Agent header first, fall back to simple request
        REMOTE_LIST=$(curl -fsSL -H "User-Agent: poor" "$LIST_URL" 2>/dev/null || curl -fsSL "$LIST_URL" 2>/dev/null)
      elif [ "$DOWNLOADER" = "wget" ]
      then
        # Try with user-agent first, fall back to simple request
        REMOTE_LIST=$(wget -qO- --user-agent="poor" "$LIST_URL" 2>/dev/null || wget -qO- "$LIST_URL" 2>/dev/null)
      fi
      ;;
    *)
      # Local directory source
      SOURCE_DIR=$(strip_trailing_slash "$BASE_URL")
      if [ -d "$SOURCE_DIR" ]
      then
        for SCRIPT_FILE in "$SOURCE_DIR"/poor*
        do
          if [ -f "$SCRIPT_FILE" ]
          then
            BASENAME=$(basename "$SCRIPT_FILE")
            REMOTE_LIST="$REMOTE_LIST$BASENAME
"
          fi
        done
        REMOTE_LIST=$(printf '%s' "$REMOTE_LIST" | grep . | sort)
      fi
      ;;
  esac

  printf '%s' "$REMOTE_LIST"
}

# Check if a tool is installed in destination
is_tool_installed() {
  TOOL_NAME="$1"
  TARGET_DEST="$2"
  EMULATE="$3"

  if [ -z "$TARGET_DEST" ] || [ ! -d "$TARGET_DEST" ]
  then
    return 1
  fi

  CHECK_NAME="$TOOL_NAME"
  if [ -n "$EMULATE" ] && [ "$TOOL_NAME" != "poor" ]
  then
    STRIPPED_NAME="${TOOL_NAME#poor}"
    if [ -n "$STRIPPED_NAME" ]
    then
      CHECK_NAME="$STRIPPED_NAME"
    fi
  fi

  [ -f "$TARGET_DEST/$CHECK_NAME" ]
}

handle_list_command() {
  shift  # remove "list" from arguments

  # Initialize variables for list functionality
  TARGET_DEST=""
  EMULATE=""
  LOCAL_ONLY=""
  REMOTE_ONLY=""
  INSTALLED_ONLY=""
  AVAILABLE_ONLY=""
  CHECK_UPDATES=1  # Default to enabled, can be disabled with --no-check-updates

  # Parse list options
  while [ $# -gt 0 ]
  do
    case "$1" in
      --dest)
        shift
        if [ $# -eq 0 ]
        then
          echo_error "option '--dest' requires an argument"
          usage_list
          return 2
        fi
        TARGET_DEST="$1"
        shift
        ;;
      --dest=*)
        TARGET_DEST="${1#--dest=}"
        shift
        ;;
      --emulate)
        EMULATE=1
        shift
        ;;
      --local)
        LOCAL_ONLY=1
        shift
        ;;
      --remote)
        REMOTE_ONLY=1
        shift
        ;;
      --installed)
        INSTALLED_ONLY=1
        shift
        ;;
      --available)
        AVAILABLE_ONLY=1
        shift
        ;;
      --no-check-updates)
        CHECK_UPDATES=""
        shift
        ;;
      -h|--help)
        usage_list
        return 0
        ;;
      --)
        shift
        break
        ;;
      -*)
        echo_error "unknown option '$1'"
        usage_list
        return 2
        ;;
      *)
        echo_error "unexpected argument '$1'"
        usage_list
        return 2
        ;;
    esac
  done

  # Get destination directory - check command line arg first, then environment variable, then default
  if [ -z "$TARGET_DEST" ] && [ -n "${DEST:-}" ]
  then
    TARGET_DEST="$DEST"
  fi

  # Use default destination if none specified and we're checking installation status
  if [ -z "$TARGET_DEST" ] && [ -z "$LOCAL_ONLY" ]
  then
    TARGET_DEST="$HOME/.local/bin"
  fi

  # Get remote JSON data for version checking if needed
  REMOTE_JSON=""
  if [ -n "$CHECK_UPDATES" ] || [ -z "$LOCAL_ONLY" ]
  then
    REMOTE_JSON=$(get_remote_tools_json 2>/dev/null || true)
  fi

  # Initialize collections
  ALL_TOOLS=""

  # Get local tools
  if [ -z "$REMOTE_ONLY" ]
  then
    initialize_install_source_directory >/dev/null 2>&1 || true

    for SCRIPT_PATH in poor*
    do
      if [ -f "$SCRIPT_PATH" ]
      then
        BASENAME=$(basename "$SCRIPT_PATH")
        if ! printf '%s\n' "$ALL_TOOLS" | grep -qx "$BASENAME"
        then
          ALL_TOOLS="$ALL_TOOLS$BASENAME
"
        fi
      fi
    done
  fi

  # Get remote tools
  if [ -z "$LOCAL_ONLY" ]
  then
    REMOTE_TOOLS=$(get_remote_tools 2>/dev/null || true)
    if [ -n "$REMOTE_TOOLS" ]
    then
      while IFS= read -r TOOL
      do
        if [ -n "$TOOL" ] && ! printf '%s\n' "$ALL_TOOLS" | grep -qx "$TOOL"
        then
          ALL_TOOLS="$ALL_TOOLS$TOOL
"
        fi
      done <<EOF
$REMOTE_TOOLS
EOF
    fi
  fi

  # Sort and deduplicate tools
  ALL_TOOLS=$(printf '%s' "$ALL_TOOLS" | grep . | sort | uniq)

  if [ -z "$ALL_TOOLS" ]
  then
    echo "No poor-tools found" >&2
    return 1
  fi

  # Display header
  if [ -n "$TARGET_DEST" ]
  then
    if [ -n "$CHECK_UPDATES" ]
    then
      printf "Available poor-tools (✅ = installed, ⚠️ = update available in %s):\n\n" "$TARGET_DEST"
    else
      printf "Available poor-tools (✅ = installed in %s):\n\n" "$TARGET_DEST"
    fi
  else
    printf "Available poor-tools:\n\n"
  fi

  # Display tools with installation status
  TOOL_COUNT=0
  INSTALLED_COUNT=0
  UPDATE_COUNT=0

  while IFS= read -r TOOL
  do
    if [ -z "$TOOL" ]
    then
      continue
    fi

    # Check installation status
    INSTALLED=""
    if [ -n "$TARGET_DEST" ]
    then
      if is_tool_installed "$TOOL" "$TARGET_DEST" "$EMULATE"
      then
        INSTALLED=1
        INSTALLED_COUNT=$((INSTALLED_COUNT + 1))
      fi
    fi

    # Check for updates
    HAS_UPDATE=""
    REMOTE_VERSION=""
    if [ -n "$CHECK_UPDATES" ] && [ -n "$INSTALLED" ]
    then
      LOCAL_VERSION=""
      # Check version of installed tool in destination directory
      if [ -n "$TARGET_DEST" ] && [ -f "$TARGET_DEST/$TOOL" ]
      then
        LOCAL_VERSION=$(get_tool_version "$TARGET_DEST/$TOOL")
      elif [ -f "$TOOL" ]
      then
        LOCAL_VERSION=$(get_tool_version "$TOOL")
      fi

      if [ -n "$LOCAL_VERSION" ] && has_tool_update "$TOOL" "$LOCAL_VERSION" "$REMOTE_JSON"
      then
        HAS_UPDATE=1
        UPDATE_COUNT=$((UPDATE_COUNT + 1))
        # Store remote version for upgrade path display
        REMOTE_VERSION=$(get_remote_tool_version "$TOOL" "$REMOTE_JSON")
      fi
    fi

    # Apply filters
    if [ -n "$INSTALLED_ONLY" ] && [ -z "$INSTALLED" ]
    then
      continue
    fi

    if [ -n "$AVAILABLE_ONLY" ] && [ -n "$INSTALLED" ]
    then
      continue
    fi

    # Format output
    if [ -n "$TARGET_DEST" ]
    then
      if [ -n "$CHECK_UPDATES" ] && [ -n "$HAS_UPDATE" ]
      then
        STATUS="⚠️"
      elif [ -n "$INSTALLED" ]
      then
        STATUS="✅"
      else
        STATUS=" "
      fi
      printf "  %s %s" "$STATUS" "$TOOL"
    else
      printf "  %s" "$TOOL"
    fi

    # Add description if available
    DESC=""
    if [ -f "$TOOL" ]
    then
      DESC=$(get_tool_description "$TOOL")
    fi

    if [ -n "$DESC" ]
    then
      printf " - %s" "$DESC"
    fi

    # Add version info if checking updates
    if [ -n "$CHECK_UPDATES" ]
    then
      LOCAL_VERSION=""
      # Check version of installed tool in destination directory
      if [ -n "$TARGET_DEST" ] && [ -f "$TARGET_DEST/$TOOL" ]
      then
        LOCAL_VERSION=$(get_tool_version "$TARGET_DEST/$TOOL")
      elif [ -f "$TOOL" ]
      then
        LOCAL_VERSION=$(get_tool_version "$TOOL")
      fi

      if [ -n "$LOCAL_VERSION" ]
      then
        # Show upgrade path if update is available
        if [ -n "$HAS_UPDATE" ] && [ -n "$REMOTE_VERSION" ]
        then
          printf " [%s -> %s]" "$LOCAL_VERSION" "$REMOTE_VERSION"
        else
          printf " [%s]" "$LOCAL_VERSION"
        fi
      fi
    fi

    printf '\n'
    TOOL_COUNT=$((TOOL_COUNT + 1))
  done <<EOF
$ALL_TOOLS
EOF

  # Display summary
  printf '\n'
  if [ -n "$TARGET_DEST" ]
  then
    if [ -n "$CHECK_UPDATES" ] && [ "$UPDATE_COUNT" -gt 0 ]
    then
      printf "Total: %d tools (%d installed, %d available, %d updates)\n" "$TOOL_COUNT" "$INSTALLED_COUNT" "$((TOOL_COUNT - INSTALLED_COUNT))" "$UPDATE_COUNT"
    else
      printf "Total: %d tools (%d installed, %d available)\n" "$TOOL_COUNT" "$INSTALLED_COUNT" "$((TOOL_COUNT - INSTALLED_COUNT))"
    fi
  else
    printf "Total: %d tools\n" "$TOOL_COUNT"
  fi

  # Display destination info
  if [ -n "$TARGET_DEST" ]
  then
    if [ -d "$TARGET_DEST" ]
    then
      printf "Installation directory: %s\n" "$TARGET_DEST"
    else
      printf "Installation directory: %s (not found)\n" "$TARGET_DEST"
    fi
  else
    printf "Use --dest DIR to check installation status\n"
  fi

  # Display update info
  if [ -n "$CHECK_UPDATES" ]
  then
    printf "Use 'poor self-update' to update the poor script\n"
    if [ "$UPDATE_COUNT" -gt 0 ]
    then
      printf "Use 'poor install --dest %s' to update tools with available updates\n" "${TARGET_DEST:-\$DEST}"
    fi
  fi
}

normalize_tool_name() {
  REQUEST=$1

  case "$REQUEST" in
    "")
      return 1
      ;;
    poor|poor.sh)
      return 1
      ;;
    install|installer)
      # Handle install command directly, not as a tool
      return 1
      ;;
    uninstall)
      # Handle uninstall command directly, not as a tool
      return 1
      ;;
    list)
      # Handle list command directly, not as a tool
      return 1
      ;;
    poor-install|poor-installer)
      # Legacy names for install - also handle directly
      return 1
      ;;
  esac

  case "$REQUEST" in
    poor-*)
      STRIPPED=${REQUEST#poor-}
      printf '%s' "poor$STRIPPED"
      return 0
      ;;
    poor*)
      printf '%s' "$REQUEST"
      return 0
      ;;
    *)
      printf '%s' "poor$REQUEST"
      return 0
      ;;
  esac
}

resolve_invocation() {
  RAW_NAME=$1

  case "$RAW_NAME" in
    sh|dash|bash|ksh|mksh|zsh)
      printf '%s' "poor"
      return 0
      ;;
  esac

  # Clean up symlink names that might have test/debug suffixes
  case "$RAW_NAME" in
    *_test|*_debug|*-test|*-debug)
      # Strip test/debug suffixes to get the actual tool name
      CLEAN_NAME=$(echo "$RAW_NAME" | sed 's/[-_]\(test\|debug\)$//')
      printf '%s' "$CLEAN_NAME"
      return 0
      ;;
  esac

  printf '%s' "$RAW_NAME"
}

DEFAULT_BASE_URL="<BASE_URL>"
if [ "$DEFAULT_BASE_URL" = "<BASE_URL_PLACEHOLDER>" ]
then
  # Only fall back to poor.tools if the placeholder wasn't replaced
  DEFAULT_BASE_URL="https://poor.tools"
fi

if [ -n "${POOR_BASE_URL-}" ]
then
  BASE_URL=$POOR_BASE_URL
else
  BASE_URL=$DEFAULT_BASE_URL
fi

SCRIPT_DIR=""
if [ -n "${POOR_TOOL_DIR-}" ]
then
  SCRIPT_DIR=$POOR_TOOL_DIR
else
  if RESOLVED_DIR=$(get_script_dir "$0" 2>/dev/null)
  then
    if [ -n "$RESOLVED_DIR" ]
    then
      SCRIPT_DIR=$RESOLVED_DIR
    fi
  fi
fi

# Extract our own version for fallback when no git repo is available
SELF_VERSION=""
if SCRIPT_VERSION=$(grep "^# version:" "$0" 2>/dev/null | head -1 | sed 's/^# version: *//')
then
  if [ "$SCRIPT_VERSION" != "<GIT_COMMIT_SHA>" ]
  then
    SELF_VERSION="$SCRIPT_VERSION"
  fi
fi

SELF_NAME_RAW=$(basename "$0")
SELF_NAME=$(resolve_invocation "$SELF_NAME_RAW")

main() {
  # Early return for sourcing support
  if [ -n "${SOURCED:-}" ]
  then
    return 0
  fi

if [ "$SELF_NAME" = "poor" ]
then
  if [ $# -eq 0 ]
  then
    usage
    exit 0
  fi

  # Parse global flags from anywhere in the command line
  NEW_ARGS=""
  while [ $# -gt 0 ]
  do
    case "$1" in
      --debug)
        DEBUG=1
        export DEBUG  # Export for use by echo.sh functions
        shift
        ;;
      --trace)
        set -x
        shift
        ;;
      *)
        NEW_ARGS="$NEW_ARGS $1"
        shift
        ;;
    esac
  done

  # Reset arguments to the filtered list
  eval set -- "$NEW_ARGS"

  if [ $# -eq 0 ]
  then
    usage
    exit 0
  fi

  case "$1" in
    -h|--help|help)
      usage
      exit 0
      ;;
    install|installer|poor-install|poor-installer)
      handle_install_command "$@"
      exit $?
      ;;
    uninstall)
      handle_uninstall_command "$@"
      exit $?
      ;;
    list)
      handle_list_command "$@"
      exit $?
      ;;
    self-update)
      shift

      # Parse self-update options
      FORCE_UPDATE=""
      while [ $# -gt 0 ]
      do
        case "$1" in
          --force)
            FORCE_UPDATE=1
            shift
            ;;
          -h|--help)
            cat <<SELF_UPDATE_HELP >&2
Usage: ${SCRIPT_NAME} self-update [--force]

Update the poor script itself to the latest version.

Options:
  --force    Force update even if current version seems newer
  -h, --help Show this help
SELF_UPDATE_HELP
            exit 0
            ;;
          -*)
            echo_error "poor self-update: unknown option: $1"
            exit 1
            ;;
          *)
            echo_error "poor self-update: unexpected argument: $1"
            exit 1
            ;;
        esac
      done

      # Determine current script path
      CURRENT_SCRIPT="$0"
      if [ ! -f "$CURRENT_SCRIPT" ]
      then
        echo_error "poor self-update: cannot determine current script path"
        exit 1
      fi

      # Get absolute path
      CURRENT_SCRIPT=$(cd "$(dirname "$CURRENT_SCRIPT")" && pwd)/$(basename "$CURRENT_SCRIPT")

      echo_info "Updating poor script: $CURRENT_SCRIPT"

      # Download new version to temporary file
      TMP_SCRIPT="${CURRENT_SCRIPT}.update.$$"
      trap_cleanup_prepare
      TMP_DOWNLOAD="$TMP_SCRIPT"

      echo_info "Downloading latest poor script..."

      if download_from_base "$TMP_SCRIPT" 1 "poor"
      then
        # Verify it's a valid poor script
        if head -5 "$TMP_SCRIPT" | grep -q "poor-tools"
        then
          # Check if we should compare versions (unless --force is used)
          if [ -z "$FORCE_UPDATE" ]
          then
            # Simple size-based check - if new version is significantly smaller, warn
            if [ -f "$CURRENT_SCRIPT" ]
            then
              CURRENT_SIZE=$(wc -c < "$CURRENT_SCRIPT" 2>/dev/null || echo "0")
              NEW_SIZE=$(wc -c < "$TMP_SCRIPT" 2>/dev/null || echo "0")

              if [ "$NEW_SIZE" -lt "$((CURRENT_SIZE / 2))" ] && [ "$NEW_SIZE" -gt 0 ]
              then
                echo_warning "New version appears significantly smaller than current version"
                echo_warning "Current: $CURRENT_SIZE bytes, New: $NEW_SIZE bytes"
                echo_warning "Use --force to update anyway"
                cleanup_tmp "$TMP_SCRIPT"
                TMP_DOWNLOAD=""
                exit 1
              fi
            fi
          fi

          # Replace current script
          mv "$TMP_SCRIPT" "$CURRENT_SCRIPT"
          chmod 755 "$CURRENT_SCRIPT"
          echo_success "Successfully updated poor script"
          TMP_DOWNLOAD=""
          exit 0
        else
          echo_error "Downloaded file doesn't appear to be a valid poor script"
          cleanup_tmp "$TMP_SCRIPT"
          TMP_DOWNLOAD=""
          exit 1
        fi
      else
        echo_error "Failed to download updated poor script"
        cleanup_tmp "$TMP_SCRIPT"
        TMP_DOWNLOAD=""
        exit 1
      fi
      ;;
    -*)
      echo_error "poor: unknown option: $1"
      usage
      exit 1
      ;;
  esac

  TOOL_REQUEST=$1
  shift
else
  TOOL_REQUEST=$SELF_NAME
fi

TARGET_NAME=$(normalize_tool_name "$TOOL_REQUEST" || printf '')
if [ -z "$TARGET_NAME" ]
then
  echo_error "poor: unable to determine tool for '$TOOL_REQUEST'"
  exit 1
fi

if [ -n "$SCRIPT_DIR" ] && [ -f "$SCRIPT_DIR/$TARGET_NAME" ]
then
  exec "$SCRIPT_DIR/$TARGET_NAME" "$@"
fi

# Check for installed version in ~/.local/bin (preferred over cache)
LOCAL_BIN_PATH="$HOME/.local/bin/$TARGET_NAME"
if [ -f "$LOCAL_BIN_PATH" ]
then
  exec "$LOCAL_BIN_PATH" "$@"
fi

if command -v "$TARGET_NAME" >/dev/null 2>&1
then
  EXEC_PATH=$(command -v "$TARGET_NAME")
  exec "$EXEC_PATH" "$@"
fi

CACHE_PATH=$(build_cache_path "$TARGET_NAME")

if [ -n "${POOR_REFRESH:-}" ] || [ -n "${POOR_NO_CACHE:-}" ]
then
  rm -f "$CACHE_PATH"
fi

if [ -z "${POOR_NO_CACHE:-}" ] && [ -f "$CACHE_PATH" ]
then
  chmod 755 "$CACHE_PATH"
  ensure_dependencies "$CACHE_PATH"
  exec "$CACHE_PATH" "$@"
fi

PRIMARY_PATH=$TARGET_NAME
SECONDARY_PATH=""
case "$TARGET_NAME" in
  poor*)
    ALT_NAME=${TARGET_NAME#poor}
    if [ -n "$ALT_NAME" ]
    then
      SECONDARY_PATH=$ALT_NAME
    fi
    ;;
esac

if [ -n "$SECONDARY_PATH" ]
then
  download_candidates "$CACHE_PATH" 1 "$PRIMARY_PATH" "$SECONDARY_PATH"
else
  download_candidates "$CACHE_PATH" 1 "$PRIMARY_PATH"
fi

ensure_dependencies "$CACHE_PATH"

chmod 755 "$CACHE_PATH"
exec "$CACHE_PATH" "$@"
}

# PLACEHOLDER_INSTALLER

main "$@"
